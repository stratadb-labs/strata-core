# v0.5.1 Spaces — Implementation Document

> **SHIPPED** — Implemented and merged in v0.5.1 (2026-02-04).

## Overview

Spaces are an organizational layer within branches. Every branch contains one or more spaces, each with its own independent instance of every primitive (KV, Event, State, JSON, Vector). Spaces are purely organizational — they are not isolation boundaries. Branches remain the unit of isolation, forking, and access control.

| Concept | Analogy | Purpose |
|---------|---------|---------|
| Branch | Git branch | Isolation, forking, merging |
| Space | Postgres schema | Organization within a branch |

### Data Model

```
strata/
├── main/                          ← branch (isolation)
│   ├── default/                   ← space (organization)
│   │   ├── kv/
│   │   ├── events/
│   │   ├── state/
│   │   ├── json/
│   │   └── vectors/
│   ├── conversations/             ← space
│   │   ├── kv/
│   │   ├── events/
│   │   └── ...
│   └── tool-results/              ← space
│       └── ...
│
├── experiment/                    ← forked branch (copies ALL spaces)
│   ├── default/
│   ├── conversations/
│   └── tool-results/
```

### Design Decisions

| Decision | Choice | Precedent |
|----------|--------|-----------|
| Each space owns its own primitives | Yes — independent KV, Event, State, JSON, Vector per space | Postgres schemas own their tables |
| Default space | `default` — implicit, always exists | Postgres `public` schema |
| Nesting | Flat (no nested spaces) | Postgres, MongoDB, MySQL |
| Cross-space transactions | Yes — a transaction can touch multiple spaces within a branch | Postgres, MongoDB (4.0+) |
| Isolation | None — branch-level access covers all spaces | Postgres schemas within a database |
| Search scope | Per-space by default, cross-space opt-in | Follows the principle of least surprise |

---

## API

### Rust

```rust
let db = Strata::open("/data/myapp")?;

// All operations go to "default" space by default
db.kv_put("key", "value")?;                     // → default/kv/key

// Switch to a named space (creates if it doesn't exist)
db.set_space("conversations")?;
db.kv_put("msg_001", payload)?;                  // → conversations/kv/msg_001
db.event_append("message", event_payload)?;       // → conversations/events/[0]

// Switch to another space
db.set_space("tool-results")?;
db.kv_put("run_42", result)?;                    // → tool-results/kv/run_42

// List spaces in the current branch
let spaces = db.list_spaces()?;                   // → ["default", "conversations", "tool-results"]

// Delete a space (must be empty or use force)
db.delete_space("tool-results")?;                 // error if non-empty
db.delete_space_force("tool-results")?;           // deletes all data in space

// Switch back to default
db.set_space("default")?;

// Cross-space reads (without switching)
let val = db.in_space("conversations", |s| s.kv_get("msg_001"))?;
```

### Multi-threaded Usage

```rust
let db = Strata::open("/data/myapp")?;

// Each handle has its own space context
let handle_a = db.new_handle()?;
let handle_b = db.new_handle()?;

std::thread::spawn(move || {
    handle_a.set_space("conversations").unwrap();
    handle_a.kv_put("msg_001", "hello").unwrap();
});

std::thread::spawn(move || {
    handle_b.set_space("tool-results").unwrap();
    handle_b.kv_put("run_42", "done").unwrap();
});
// No interference — each handle tracks its own active space.
```

### Cross-Space Transactions

```rust
let session = db.session();
session.begin()?;

session.set_space("conversations")?;
session.kv_put("msg_001", "hello")?;

session.set_space("user-profiles")?;
session.kv_put("alice", profile)?;

session.commit()?; // atomic across both spaces
```

### Space Naming Rules

Following conventions from Postgres schema naming:

- **Allowed characters**: lowercase `a-z`, digits `0-9`, hyphens `-`, underscores `_`
- **Must start with**: a letter
- **Max length**: 64 characters
- **Reserved prefix**: `_system_` (reserved for intelligence layer, hidden from `list_spaces`)
- **Reserved name**: `default` (cannot be deleted)
- **Case**: case-sensitive, but convention is lowercase

```rust
// Valid
db.set_space("conversations")?;       // ✓
db.set_space("tool-results")?;        // ✓
db.set_space("agent_memory_v2")?;     // ✓

// Invalid
db.set_space("Conversations")?;       // ✗ uppercase
db.set_space("123-invalid")?;         // ✗ starts with digit
db.set_space("")?;                    // ✗ empty
db.set_space("a".repeat(65))?;        // ✗ too long
db.set_space("_system_embeddings")?;  // ✗ reserved prefix (for user code)
```

---

## Architecture

### Where Space Lives in the Key Hierarchy

**Current Key structure** (`crates/core/src/types.rs`):

```
Key {
    namespace: Namespace {
        tenant: String,       // "default"
        app: String,          // "default"
        agent: String,        // "default"
        branch_id: BranchId,  // UUID
    },
    type_tag: TypeTag,        // KV=0x01, Event=0x02, State=0x03, ...
    user_key: Vec<u8>,        // "msg_001"
}
```

**New Key structure with space:**

```
Key {
    namespace: Namespace {
        tenant: String,
        app: String,
        agent: String,
        branch_id: BranchId,
        space: String,         // ← NEW: "default", "conversations", etc.
    },
    type_tag: TypeTag,
    user_key: Vec<u8>,
}
```

Space becomes part of the Namespace. This means:

- Keys in different spaces never collide (different namespace = different key)
- Prefix scans are naturally scoped to a space (same namespace comparison)
- ShardedStore sharding by BranchId continues to work (spaces within a branch share a shard — no cross-branch contention)
- Key ordering: tenant → app → agent → branch_id → **space** → type_tag → user_key

### Why Space Goes in Namespace (Not in User Key)

Alternatives considered:

| Approach | Pros | Cons |
|----------|------|------|
| **In Namespace** (chosen) | Clean isolation, prefix scans just work, no delimiter ambiguity | Namespace grows by one field |
| In user_key prefix | No Namespace change | Delimiter collisions, prefix scans break, user must never use the delimiter |
| Separate field in Key | Explicit | Third axis in ordering, complex starts_with logic |

The Namespace approach is the cleanest: it extends the existing hierarchy naturally, and every operation that constructs a Namespace (`Namespace::for_branch()`) becomes the single integration point.

---

## Implementation Plan

### Layer 1: Core Types (`strata-core`)

**File: `crates/core/src/types.rs`**

1. Add `space: String` field to `Namespace`:

```rust
pub struct Namespace {
    pub tenant: String,
    pub app: String,
    pub agent: String,
    pub branch_id: BranchId,
    pub space: String,           // NEW
}
```

2. Update `Namespace::for_branch()` to include default space:

```rust
pub fn for_branch(branch_id: BranchId) -> Self {
    Self {
        tenant: "default".to_string(),
        app: "default".to_string(),
        agent: "default".to_string(),
        branch_id,
        space: "default".to_string(),  // NEW
    }
}
```

3. Add `Namespace::for_branch_space()`:

```rust
pub fn for_branch_space(branch_id: BranchId, space: &str) -> Self {
    Self {
        tenant: "default".to_string(),
        app: "default".to_string(),
        agent: "default".to_string(),
        branch_id,
        space: space.to_string(),
    }
}
```

4. Update `Namespace::fmt()` Display:

```rust
// Before: "default/default/default/{branch_id}"
// After:  "default/default/default/{branch_id}/{space}"
fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
    write!(f, "{}/{}/{}/{}/{}", self.tenant, self.app, self.agent, self.branch_id, self.space)
}
```

5. Update `Namespace::cmp()` Ord — space sorts after branch_id:

```rust
impl Ord for Namespace {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.tenant.cmp(&other.tenant)
            .then(self.app.cmp(&other.app))
            .then(self.agent.cmp(&other.agent))
            .then(self.branch_id.0.cmp(&other.branch_id.0))
            .then(self.space.cmp(&other.space))  // NEW
    }
}
```

6. Add space validation function:

```rust
pub fn validate_space_name(name: &str) -> Result<(), String> {
    if name.is_empty() {
        return Err("Space name cannot be empty".into());
    }
    if name.len() > 64 {
        return Err("Space name cannot exceed 64 characters".into());
    }
    if !name.as_bytes()[0].is_ascii_lowercase() {
        return Err("Space name must start with a lowercase letter".into());
    }
    if !name.bytes().all(|b| b.is_ascii_lowercase() || b.is_ascii_digit() || b == b'-' || b == b'_') {
        return Err("Space name can only contain lowercase letters, digits, hyphens, and underscores".into());
    }
    if name.starts_with("_system_") {
        return Err("Space names starting with '_system_' are reserved".into());
    }
    Ok(())
}
```

**Impact**: Every place that constructs a `Namespace` or deserializes one will need updating. The compiler will catch all of them because `Namespace` gains a new required field.

### Layer 2: Storage (`strata-storage`)

**File: `crates/storage/src/sharded.rs`**

No structural changes needed. The ShardedStore shards by BranchId (extracted from the Key's namespace). Spaces within the same branch share a shard. This is correct: spaces are organizational, not isolation boundaries.

The BTreeSet index continues to work because Key ordering now includes space in the namespace comparison. Prefix scans within a space naturally exclude keys from other spaces.

### Layer 3: WAL / Durability (`strata-durability`)

**File: `crates/durability/src/format/wal_record.rs`**

The WAL record currently stores `branch_id: [u8; 16]` as a fixed-size field. Space needs to be added.

**Option A: Add space to WAL record (clean break)**

Add a space field to the WAL record payload:

```
Current layout:
[format_ver:1][txn_id:8][branch_id:16][timestamp:8][writeset:var]

New layout:
[format_ver:1][txn_id:8][branch_id:16][timestamp:8][space_len:2][space:var][writeset:var]
```

- Bump `WAL_RECORD_FORMAT_VERSION` from 1 to 2
- `space_len`: 2-byte little-endian length prefix (max 64 chars, fits in u16)
- `space`: UTF-8 space name bytes
- Old format v1 records without space are treated as `"default"` during recovery

**Option B: Space is already in the writeset (no WAL change)**

The writeset already contains the full `Key` (which includes `Namespace`). During recovery, the Namespace is deserialized from the writeset's EntityRef, which already includes the full key. If the Namespace now contains `space`, the writeset serialization picks it up automatically.

Let's check: the writeset `EntityRef` format (`crates/durability/src/format/writeset.rs`) serializes keys which include the full Namespace. If the Namespace serialization (via serde) includes the `space` field, then the writeset already carries space context.

**Recommendation: Option B** — rely on the writeset's key serialization to carry space context. The top-level `branch_id` field in the WAL record is used for shard routing during recovery (which shard to replay into), not for key construction. Since spaces share a shard with their branch, no change to the WAL record header is needed.

**Backwards compatibility**: Old WAL records have Namespace without `space`. Serde's `#[serde(default)]` on the `space` field handles this:

```rust
pub struct Namespace {
    pub tenant: String,
    pub app: String,
    pub agent: String,
    pub branch_id: BranchId,
    #[serde(default = "default_space_name")]
    pub space: String,
}

fn default_space_name() -> String {
    "default".to_string()
}
```

Old records deserialize with `space = "default"`. No migration needed.

### Layer 4: Engine Primitives (`strata-engine`)

Each primitive facade constructs Namespaces via `Namespace::for_branch(branch_id)`. All of these need to accept a space parameter.

**File: `crates/engine/src/primitives/kv.rs`**

```rust
// Before
fn namespace_for_branch(&self, branch_id: &BranchId) -> Namespace {
    Namespace::for_branch(*branch_id)
}

// After
fn namespace_for(&self, branch_id: &BranchId, space: &str) -> Namespace {
    Namespace::for_branch_space(*branch_id, space)
}

fn key_for(&self, branch_id: &BranchId, space: &str, user_key: &str) -> Key {
    Key::new_kv(self.namespace_for(branch_id, space), user_key)
}
```

All public methods gain a `space: &str` parameter:

```rust
pub fn get(&self, branch_id: &BranchId, space: &str, key: &str) -> StrataResult<Option<Value>> { ... }
pub fn put(&self, branch_id: &BranchId, space: &str, key: &str, value: Value) -> StrataResult<Version> { ... }
pub fn delete(&self, branch_id: &BranchId, space: &str, key: &str) -> StrataResult<bool> { ... }
pub fn list(&self, branch_id: &BranchId, space: &str, prefix: Option<&str>) -> StrataResult<Vec<String>> { ... }
```

**Same pattern applies to:**
- `crates/engine/src/primitives/event.rs` — EventLog
- `crates/engine/src/primitives/state.rs` — StateCell
- `crates/engine/src/primitives/json.rs` — JsonStore
- `crates/engine/src/primitives/vector/store.rs` — VectorStore

Each primitive is a stateless facade that takes `branch_id` as a parameter. Adding `space` alongside it is mechanical.

### Layer 5: Executor (`strata-executor`)

#### 5a. Strata Handle — Add Space Context

**File: `crates/executor/src/api/mod.rs`**

```rust
pub struct Strata {
    executor: Executor,
    current_branch: BranchId,
    current_space: String,          // NEW — defaults to "default"
    access_mode: AccessMode,
}
```

Add space methods:

```rust
impl Strata {
    /// Get the current space name.
    pub fn current_space(&self) -> &str {
        &self.current_space
    }

    /// Switch to a space (creates if it doesn't exist).
    pub fn set_space(&mut self, space_name: &str) -> Result<()> {
        validate_space_name(space_name)?;
        // Register space in branch metadata if new
        self.ensure_space_exists(space_name)?;
        self.current_space = space_name.to_string();
        Ok(())
    }

    /// List all user-visible spaces in the current branch.
    pub fn list_spaces(&self) -> Result<Vec<String>> { ... }

    /// Delete a space (must be empty).
    pub fn delete_space(&self, space_name: &str) -> Result<()> { ... }

    /// Delete a space and all its data.
    pub fn delete_space_force(&self, space_name: &str) -> Result<()> { ... }

    /// Execute a closure in a different space without switching.
    pub fn in_space<F, R>(&self, space: &str, f: F) -> Result<R>
    where F: FnOnce(&SpaceHandle<'_>) -> Result<R> { ... }
}
```

Update `new_handle()` to start on `"default"` space (same as branches):

```rust
pub fn new_handle(&self) -> Result<Self> {
    let db = self.executor.primitives().db.clone();
    // New handle starts on "default" space, not the parent's current space
    Self::from_database_with_mode(db, self.access_mode)
}
```

#### 5b. Commands — Add Space Field

**File: `crates/executor/src/command.rs`**

Every data-scoped command gains an optional `space` field (same pattern as `branch`):

```rust
Command::KvPut {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    branch: Option<BranchId>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    space: Option<String>,          // NEW
    key: String,
    value: Value,
},
```

Update `resolve_default_branch()` → `resolve_defaults()`:

```rust
pub fn resolve_defaults(&mut self) {
    macro_rules! resolve {
        ($branch:expr, $space:expr) => {
            if $branch.is_none() { *$branch = Some(BranchId::default()); }
            if $space.is_none() { *$space = Some("default".to_string()); }
        };
    }

    match self {
        Command::KvPut { branch, space, .. }
        | Command::KvGet { branch, space, .. }
        | Command::KvDelete { branch, space, .. }
        // ... all data commands
        => { resolve!(branch, space); }

        // Branch/Transaction/Database commands unchanged
        _ => {}
    }
}
```

#### 5c. Space Management Commands

**File: `crates/executor/src/command.rs`**

Add new commands:

```rust
/// List spaces in a branch.
/// Returns: Output::SpaceList
SpaceList {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    branch: Option<BranchId>,
},

/// Create a space explicitly.
/// Returns: Output::Unit
SpaceCreate {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    branch: Option<BranchId>,
    space: String,
},

/// Delete a space (must be empty unless force=true).
/// Returns: Output::Unit
SpaceDelete {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    branch: Option<BranchId>,
    space: String,
    #[serde(default)]
    force: bool,
},

/// Check if a space exists.
/// Returns: Output::Bool
SpaceExists {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    branch: Option<BranchId>,
    space: String,
},
```

#### 5d. Output — Add SpaceList Variant

**File: `crates/executor/src/output.rs`**

```rust
/// List of space names
SpaceList(Vec<String>),
```

#### 5e. Handlers

**File: `crates/executor/src/handlers/space.rs` (NEW)**

```rust
pub fn space_list(primitives: &Primitives, branch: BranchId) -> Result<Output> { ... }
pub fn space_create(primitives: &Primitives, branch: BranchId, space: String) -> Result<Output> { ... }
pub fn space_delete(primitives: &Primitives, branch: BranchId, space: String, force: bool) -> Result<Output> { ... }
pub fn space_exists(primitives: &Primitives, branch: BranchId, space: String) -> Result<Output> { ... }
```

**Existing handlers** (`kv.rs`, `event.rs`, `state.rs`, `json.rs`, `vector.rs`, `search.rs`):

Every handler function gains a `space: String` parameter and passes it through to the engine primitive:

```rust
// Before
pub fn kv_put(primitives: &Primitives, branch: BranchId, key: String, value: Value) -> Result<Output> {
    let version = primitives.kv.put(&branch, &key, value)?;
    Ok(Output::Version(version.as_u64()))
}

// After
pub fn kv_put(primitives: &Primitives, branch: BranchId, space: String, key: String, value: Value) -> Result<Output> {
    let version = primitives.kv.put(&branch, &space, &key, value)?;
    Ok(Output::Version(version.as_u64()))
}
```

#### 5f. API Methods — Pass Space Context

**File: `crates/executor/src/api/kv.rs` (and all other api/*.rs files)**

```rust
// Before
pub fn kv_put(&self, key: &str, value: impl Into<Value>) -> Result<u64> {
    match self.executor.execute(Command::KvPut {
        branch: self.branch_id(),
        key: key.to_string(),
        value: value.into(),
    })? {
        Output::Version(v) => Ok(v),
        _ => Err(Error::Internal { reason: "unexpected output".into() }),
    }
}

// After
pub fn kv_put(&self, key: &str, value: impl Into<Value>) -> Result<u64> {
    match self.executor.execute(Command::KvPut {
        branch: self.branch_id(),
        space: self.space_id(),          // NEW — returns Some(self.current_space.clone())
        key: key.to_string(),
        value: value.into(),
    })? {
        Output::Version(v) => Ok(v),
        _ => Err(Error::Internal { reason: "unexpected output".into() }),
    }
}
```

### Layer 6: Space Metadata Storage

Spaces need to be tracked per-branch so we can list them, check existence, and enumerate during fork.

**Approach**: Store space metadata using a reserved TypeTag or a well-known key pattern in the branch's KV store.

Add a new TypeTag for space metadata:

```rust
// crates/core/src/types.rs
pub enum TypeTag {
    KV = 0x01,
    Event = 0x02,
    State = 0x03,
    Branch = 0x05,
    Space = 0x06,       // NEW — space metadata
    Vector = 0x10,
    Json = 0x11,
    VectorConfig = 0x12,
}
```

Space metadata key: `Key::new_space(namespace, space_name)` where namespace uses the **branch-level** namespace (space="default" or a sentinel) to avoid circular dependency.

```rust
// crates/core/src/types.rs
impl Key {
    /// Create a space metadata key.
    /// Uses the branch-level namespace (space is not part of the space registry key).
    pub fn new_space(branch_id: BranchId, space_name: &str) -> Self {
        let namespace = Namespace::for_branch(branch_id); // uses space="default"
        Self::new(namespace, TypeTag::Space, space_name.as_bytes().to_vec())
    }

    /// Prefix for scanning all space metadata in a branch.
    pub fn new_space_prefix(branch_id: BranchId) -> Self {
        let namespace = Namespace::for_branch(branch_id);
        Self::new(namespace, TypeTag::Space, vec![])
    }
}
```

Space metadata value: a simple struct serialized as `Value::Bytes`:

```rust
#[derive(Serialize, Deserialize)]
pub struct SpaceMetadata {
    pub name: String,
    pub created_at: u64,  // microseconds since epoch
}
```

**Operations:**

- `space_create`: Write `SpaceMetadata` at `Key::new_space(branch_id, name)`
- `space_list`: Prefix scan `Key::new_space_prefix(branch_id)`, filter out `_system_*`
- `space_exists`: Check existence at `Key::new_space(branch_id, name)`
- `space_delete`: Delete metadata key + all data keys in that space (if force)
- `set_space` (auto-create): Check existence, create if missing, then set handle state

The `"default"` space metadata is created alongside the branch in `ensure_default_branch()`.

---

## Backwards Compatibility

### Existing Data

Old data has `Namespace { tenant, app, agent, branch_id }` without a `space` field. With `#[serde(default = "default_space_name")]` on the `space` field, old serialized Namespaces deserialize with `space = "default"`.

This means:
- Old WAL records replay correctly (writeset keys get `space = "default"`)
- Old snapshot data loads correctly
- No migration step required
- Existing tests pass without modification (they all operate on `"default"` space implicitly)

### API Compatibility

- `Strata::open()` starts on `"default"` space (same as before)
- All existing API calls work unchanged (they target `"default"` space)
- `Command` JSON without a `space` field defaults to `"default"` via `resolve_defaults()`
- New `space` field is `skip_serializing_if = "Option::is_none"` — old consumers don't see it

---

## Sample Usages

### 1. AI Agent with Organized Memory

```rust
let mut db = Strata::open("/data/agent")?;

// Store conversation history
db.set_space("conversations")?;
db.event_append("user_message", json!({ "content": "What's the weather?" }))?;
db.event_append("assistant_message", json!({ "content": "Let me check..." }))?;
db.event_append("tool_call", json!({ "tool": "weather_api", "status": "ok" }))?;

// Store tool results separately
db.set_space("tool-results")?;
db.kv_put("weather_api:run_1", json!({ "temp": 72, "conditions": "sunny" }))?;

// Store user preferences
db.set_space("user-context")?;
db.state_set("preferences", json!({ "units": "fahrenheit", "location": "SF" }))?;

// Each space has its own event log
db.set_space("conversations")?;
assert_eq!(db.event_len()?, 3);  // 3 events

db.set_space("tool-results")?;
assert_eq!(db.event_len()?, 0);  // 0 events (only KV data here)
```

### 2. Multi-Tenant Application

```rust
let mut db = Strata::open("/data/app")?;

// Each tenant gets a space
for tenant in ["acme-corp", "globex", "initech"] {
    db.set_space(tenant)?;
    db.kv_put("config", json!({ "plan": "enterprise" }))?;
    db.vector_create_collection("docs", 384, DistanceMetric::Cosine)?;
}

// List all tenant spaces
let spaces = db.list_spaces()?;
// → ["acme-corp", "default", "globex", "initech"]
```

### 3. Experiment Tracking with Branch + Space

```rust
let mut db = Strata::open("/data/ml")?;

// Set up training data in the main branch
db.set_space("training-data")?;
db.kv_put("dataset_v1", dataset_bytes)?;

db.set_space("hyperparams")?;
db.kv_put("config", json!({ "lr": 0.001, "epochs": 10 }))?;

// Fork the branch to try different hyperparameters
db.fork_branch("experiment-high-lr")?;    // copies ALL spaces
db.set_branch("experiment-high-lr")?;

db.set_space("hyperparams")?;
db.kv_put("config", json!({ "lr": 0.01, "epochs": 10 }))?;  // only this space diverges

// Diff shows changes scoped by space
let diff = db.branches().diff("default", "experiment-high-lr")?;
// → { space: "hyperparams", kv: { changed: ["config"] } }
// → { space: "training-data", kv: { changed: [] } }  // no changes
```

### 4. Cross-Space Transaction

```rust
let mut db = Strata::open("/data/app")?;

let session = db.session();
session.begin()?;

// Deduct credits in one space
session.set_space("billing")?;
let credits = session.kv_get("credits")?.unwrap();
session.kv_put("credits", credits.as_i64().unwrap() - 1)?;

// Record the API call in another space
session.set_space("api-logs")?;
session.event_append("api_call", json!({ "endpoint": "/search", "tokens": 150 }))?;

session.commit()?; // atomic: both spaces or neither
```

### 5. Python SDK (Future — v0.7)

```python
import strata

db = strata.open("/data/agent")

# Default space
db.kv_put("key", "value")

# Switch space
db.set_space("conversations")
db.kv_put("msg_001", {"role": "user", "content": "hello"})

# List spaces
spaces = db.list_spaces()  # ["conversations", "default"]

# Cross-space read
val = db.in_space("default", lambda s: s.kv_get("key"))
```

### 6. MCP Server (Future — v0.5.3)

```json
// Set space tool
{ "name": "set_space", "params": { "space": "conversations" } }

// KV put — goes to active space
{ "name": "kv_put", "params": { "key": "msg_001", "value": "hello" } }

// Explicit space override (optional)
{ "name": "kv_put", "params": { "space": "tool-results", "key": "run_42", "value": "done" } }

// List spaces
{ "name": "list_spaces", "params": {} }
// → { "spaces": ["conversations", "default", "tool-results"] }
```

---

## Files Changed

### New Files

| File | Description |
|------|-------------|
| `crates/executor/src/handlers/space.rs` | Space management handlers (list, create, delete, exists) |
| `crates/executor/src/api/space.rs` | High-level space API methods on Strata handle |

### Modified Files

| File | Changes |
|------|---------|
| `crates/core/src/types.rs` | Add `space` to `Namespace`, add `TypeTag::Space`, add `Key::new_space()`, add `validate_space_name()`, update `Namespace::cmp/Display` |
| `crates/engine/src/primitives/kv.rs` | Add `space` parameter to all methods, update namespace construction |
| `crates/engine/src/primitives/event.rs` | Add `space` parameter to all methods |
| `crates/engine/src/primitives/state.rs` | Add `space` parameter to all methods |
| `crates/engine/src/primitives/json.rs` | Add `space` parameter to all methods |
| `crates/engine/src/primitives/vector/store.rs` | Add `space` parameter to all methods |
| `crates/executor/src/command.rs` | Add `space: Option<String>` to all data commands, add Space* commands, update `resolve_defaults()` |
| `crates/executor/src/output.rs` | Add `SpaceList` variant |
| `crates/executor/src/executor.rs` | Dispatch Space* commands, pass `space` to all handlers |
| `crates/executor/src/api/mod.rs` | Add `current_space` field to `Strata`, add `set_space()`, `list_spaces()`, `delete_space()` |
| `crates/executor/src/api/kv.rs` | Pass `self.space_id()` in all Command constructions |
| `crates/executor/src/api/event.rs` | Pass `self.space_id()` in all Command constructions |
| `crates/executor/src/api/state.rs` | Pass `self.space_id()` in all Command constructions |
| `crates/executor/src/api/json.rs` | Pass `self.space_id()` in all Command constructions |
| `crates/executor/src/api/vector.rs` | Pass `self.space_id()` in all Command constructions |
| `crates/executor/src/handlers/kv.rs` | Accept and pass `space` parameter |
| `crates/executor/src/handlers/event.rs` | Accept and pass `space` parameter |
| `crates/executor/src/handlers/state.rs` | Accept and pass `space` parameter |
| `crates/executor/src/handlers/json.rs` | Accept and pass `space` parameter |
| `crates/executor/src/handlers/vector.rs` | Accept and pass `space` parameter |
| `crates/executor/src/handlers/search.rs` | Accept and pass `space` parameter |
| `crates/executor/src/handlers/mod.rs` | Add `pub mod space;` |
| `crates/executor/src/bridge.rs` | Pass space through bridge conversions |
| `crates/executor/src/session.rs` | Add `current_space` to Session, add `set_space()` |

---

## Testing Strategy

### Unit Tests (in each crate)

**`crates/core/src/types.rs`**:
- `validate_space_name` accepts valid names, rejects invalid
- `Namespace` ordering: same branch, different spaces sort correctly
- `Namespace` serialization roundtrip with `space` field
- `Namespace` deserialization without `space` field defaults to `"default"` (backwards compat)
- `Key::new_space` prefix scan matches space metadata keys

**`crates/engine/src/primitives/kv.rs`** (and all primitives):
- Same key in different spaces are independent
- Operations in space "a" don't affect space "b"
- Default space works when no space is specified

### Integration Tests (executor level)

**`crates/executor/src/tests/spaces.rs`**:

```rust
#[test] fn test_default_space_on_open()
#[test] fn test_set_space_creates_if_not_exists()
#[test] fn test_set_space_invalid_name_rejected()
#[test] fn test_list_spaces_includes_default()
#[test] fn test_list_spaces_excludes_system()
#[test] fn test_delete_space_empty()
#[test] fn test_delete_space_non_empty_fails()
#[test] fn test_delete_space_force()
#[test] fn test_delete_default_space_fails()
#[test] fn test_kv_isolation_across_spaces()
#[test] fn test_event_isolation_across_spaces()
#[test] fn test_state_isolation_across_spaces()
#[test] fn test_json_isolation_across_spaces()
#[test] fn test_vector_isolation_across_spaces()
#[test] fn test_cross_space_transaction()
#[test] fn test_new_handle_starts_on_default_space()
#[test] fn test_set_space_per_handle_isolation()
#[test] fn test_space_survives_restart() // disk-backed test
#[test] fn test_backwards_compat_no_space_field_in_command()
```

### Verification Commands

```bash
cargo build -p strata-core          # Namespace change compiles
cargo build -p strata-storage       # No changes needed
cargo build -p strata-engine        # Primitive changes compile
cargo build -p strata-executor      # Command/handler changes compile
cargo test -p strata-core           # Type tests pass
cargo test -p strata-engine         # Primitive tests pass
cargo test -p strata-executor       # All tests pass (existing + new)
cargo test                          # Full workspace green
```

---

## Implementation Order

The implementation should proceed bottom-up through the crate dependency graph:

1. **`strata-core`** — Add `space` to `Namespace`, `TypeTag::Space`, validation, key helpers
2. **Fix compilation** — Update all `Namespace` construction sites across `strata-engine` and `strata-executor` to pass `space` (mechanical, compiler-guided)
3. **Engine primitives** — Add `space` parameter to KV, Event, State, JSON, Vector facades
4. **Executor commands** — Add `space` to Command variants, update `resolve_defaults()`
5. **Executor handlers** — Pass `space` through to engine primitives
6. **Executor API** — Add `current_space` to Strata handle, `set_space()`, API methods pass space
7. **Space management** — SpaceCreate/List/Delete/Exists commands and handlers
8. **Space metadata** — Storage of space registry per branch
9. **Tests** — Unit + integration tests

Steps 1-2 will cause a large number of compilation errors that are resolved mechanically. Once the core type change compiles, the rest is incremental.

---

## Open Questions

1. **Should `set_space` auto-create?** Current design says yes (like `mkdir -p`). Alternative: require explicit `create_space()` first (like `CREATE SCHEMA`). Auto-create is more ergonomic for AI agents. Explicit create is safer for applications. **Current decision: auto-create.**

2. **Should `in_space()` exist?** It's convenient for cross-space reads without switching, but adds API surface. Could defer to v0.5.2 if it complicates the initial implementation. **Decision: defer if needed.**

3. **Should space names be case-insensitive?** Postgres schema names are case-insensitive by default. Our validation requires lowercase, which achieves the same effect without ambiguity. **Decision: lowercase only, case-sensitive matching.**
