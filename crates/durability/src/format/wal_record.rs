//! WAL segment file and record format.
//!
//! WAL segments are named `wal-NNNNNN.seg` where `NNNNNN` is a zero-padded segment number.
//!
//! # Segment Layout
//!
//! ```text
//! ┌────────────────────────────────────┐
//! │ Segment Header (32 bytes)          │
//! ├────────────────────────────────────┤
//! │ Record 1                           │
//! ├────────────────────────────────────┤
//! │ Record 2                           │
//! ├────────────────────────────────────┤
//! │ ...                                │
//! └────────────────────────────────────┘
//! ```
//!
//! # Record Layout
//!
//! ```text
//! ┌─────────────────┬──────────────────┬─────────────────────────┬──────────┐
//! │ Length (4 bytes)│ Format Ver (1)   │ Payload (variable)      │ CRC32 (4)│
//! └─────────────────┴──────────────────┴─────────────────────────┴──────────┘
//!
//! Payload:
//! ┌──────────────┬──────────────┬──────────────┬─────────────────────────────┐
//! │ TxnId (8)    │ BranchId (16)   │ Timestamp (8)│ Writeset (variable)         │
//! └──────────────┴──────────────┴──────────────┴─────────────────────────────┘
//! ```

use crc32fast::Hasher;
use std::fs::{File, OpenOptions};
use std::io::{Read, Seek, SeekFrom, Write};
use std::path::{Path, PathBuf};

/// Magic bytes identifying a WAL segment file: "STRA"
pub const SEGMENT_MAGIC: [u8; 4] = *b"STRA";

/// Current segment format version
pub const SEGMENT_FORMAT_VERSION: u32 = 1;

/// Size of segment header in bytes
pub const SEGMENT_HEADER_SIZE: usize = 32;

/// Current WAL record format version
pub const WAL_RECORD_FORMAT_VERSION: u8 = 1;

/// WAL segment header (32 bytes).
///
/// The header is written at the beginning of each segment file and contains
/// metadata for validation and compatibility checking.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
pub struct SegmentHeader {
    /// Magic bytes: "STRA" (0x53545241)
    pub magic: [u8; 4],

    /// Format version for forward compatibility
    pub format_version: u32,

    /// Segment number (monotonically increasing)
    pub segment_number: u64,

    /// Database UUID (for integrity checking across segments)
    pub database_uuid: [u8; 16],
}

impl SegmentHeader {
    /// Create a new segment header.
    pub fn new(segment_number: u64, database_uuid: [u8; 16]) -> Self {
        SegmentHeader {
            magic: SEGMENT_MAGIC,
            format_version: SEGMENT_FORMAT_VERSION,
            segment_number,
            database_uuid,
        }
    }

    /// Serialize header to bytes.
    pub fn to_bytes(&self) -> [u8; SEGMENT_HEADER_SIZE] {
        let mut bytes = [0u8; SEGMENT_HEADER_SIZE];
        bytes[0..4].copy_from_slice(&self.magic);
        bytes[4..8].copy_from_slice(&self.format_version.to_le_bytes());
        bytes[8..16].copy_from_slice(&self.segment_number.to_le_bytes());
        bytes[16..32].copy_from_slice(&self.database_uuid);
        bytes
    }

    /// Deserialize header from bytes.
    pub fn from_bytes(bytes: &[u8; SEGMENT_HEADER_SIZE]) -> Option<Self> {
        Some(SegmentHeader {
            magic: bytes[0..4].try_into().ok()?,
            format_version: u32::from_le_bytes(bytes[4..8].try_into().ok()?),
            segment_number: u64::from_le_bytes(bytes[8..16].try_into().ok()?),
            database_uuid: bytes[16..32].try_into().ok()?,
        })
    }

    /// Validate the header has correct magic bytes.
    pub fn is_valid(&self) -> bool {
        self.magic == SEGMENT_MAGIC
    }
}

/// WAL segment file handle.
///
/// A segment is a single WAL file containing multiple records.
/// Only the active segment is writable; closed segments are immutable.
pub struct WalSegment {
    /// File handle
    file: File,

    /// Segment number
    segment_number: u64,

    /// Current write position (bytes from start)
    write_position: u64,

    /// Path to segment file
    path: PathBuf,

    /// Whether this segment is closed (immutable)
    closed: bool,

    /// Database UUID for this segment
    database_uuid: [u8; 16],
}

impl WalSegment {
    /// Create a new WAL segment.
    ///
    /// Creates a new segment file and writes the header.
    pub fn create(
        dir: &Path,
        segment_number: u64,
        database_uuid: [u8; 16],
    ) -> std::io::Result<Self> {
        let path = Self::segment_path(dir, segment_number);

        let mut file = OpenOptions::new()
            .create_new(true)
            .write(true)
            .read(true)
            .open(&path)?;

        // Write header
        let header = SegmentHeader::new(segment_number, database_uuid);
        file.write_all(&header.to_bytes())?;

        Ok(WalSegment {
            file,
            segment_number,
            write_position: SEGMENT_HEADER_SIZE as u64,
            path,
            closed: false,
            database_uuid,
        })
    }

    /// Open an existing WAL segment for reading.
    ///
    /// Validates the header and positions at the end for size calculation.
    pub fn open_read(dir: &Path, segment_number: u64) -> std::io::Result<Self> {
        let path = Self::segment_path(dir, segment_number);

        let mut file = OpenOptions::new().read(true).open(&path)?;

        // Read and validate header
        let mut header_bytes = [0u8; SEGMENT_HEADER_SIZE];
        file.read_exact(&mut header_bytes)?;

        let header = SegmentHeader::from_bytes(&header_bytes).ok_or_else(|| {
            std::io::Error::new(std::io::ErrorKind::InvalidData, "Invalid segment header")
        })?;

        if !header.is_valid() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid segment magic bytes",
            ));
        }

        if header.segment_number != segment_number {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                format!(
                    "Segment number mismatch: expected {}, got {}",
                    segment_number, header.segment_number
                ),
            ));
        }

        let write_position = file.seek(SeekFrom::End(0))?;

        Ok(WalSegment {
            file,
            segment_number: header.segment_number,
            write_position,
            path,
            closed: true, // Opened for reading = treat as closed
            database_uuid: header.database_uuid,
        })
    }

    /// Open an existing WAL segment for appending.
    ///
    /// Used when resuming writes to an existing active segment.
    pub fn open_append(dir: &Path, segment_number: u64) -> std::io::Result<Self> {
        let path = Self::segment_path(dir, segment_number);

        let mut file = OpenOptions::new().read(true).write(true).open(&path)?;

        // Read and validate header
        let mut header_bytes = [0u8; SEGMENT_HEADER_SIZE];
        file.read_exact(&mut header_bytes)?;

        let header = SegmentHeader::from_bytes(&header_bytes).ok_or_else(|| {
            std::io::Error::new(std::io::ErrorKind::InvalidData, "Invalid segment header")
        })?;

        if !header.is_valid() {
            return Err(std::io::Error::new(
                std::io::ErrorKind::InvalidData,
                "Invalid segment magic bytes",
            ));
        }

        // Seek to end for appending
        let write_position = file.seek(SeekFrom::End(0))?;

        Ok(WalSegment {
            file,
            segment_number: header.segment_number,
            write_position,
            path,
            closed: false,
            database_uuid: header.database_uuid,
        })
    }

    /// Generate segment file path.
    ///
    /// Format: `wal-NNNNNN.seg` where NNNNNN is zero-padded segment number.
    pub fn segment_path(dir: &Path, segment_number: u64) -> PathBuf {
        dir.join(format!("wal-{:06}.seg", segment_number))
    }

    /// Get segment number.
    pub fn segment_number(&self) -> u64 {
        self.segment_number
    }

    /// Get current segment size in bytes.
    pub fn size(&self) -> u64 {
        self.write_position
    }

    /// Get the file path.
    pub fn path(&self) -> &Path {
        &self.path
    }

    /// Get database UUID.
    pub fn database_uuid(&self) -> [u8; 16] {
        self.database_uuid
    }

    /// Write bytes to segment and update write position.
    ///
    /// Returns an error if the segment is closed.
    pub fn write(&mut self, data: &[u8]) -> std::io::Result<()> {
        if self.closed {
            return Err(std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                "Cannot write to closed segment",
            ));
        }

        self.file.write_all(data)?;
        self.write_position += data.len() as u64;
        Ok(())
    }

    /// Sync segment data to disk.
    pub fn sync(&mut self) -> std::io::Result<()> {
        self.file.sync_all()
    }

    /// Mark segment as closed (immutable).
    ///
    /// Syncs data to disk before closing.
    pub fn close(&mut self) -> std::io::Result<()> {
        if !self.closed {
            self.file.sync_all()?;
            self.closed = true;
        }
        Ok(())
    }

    /// Check if segment is closed.
    pub fn is_closed(&self) -> bool {
        self.closed
    }

    /// Get mutable reference to file (for reading).
    pub fn file_mut(&mut self) -> &mut File {
        &mut self.file
    }

    /// Seek to a specific position for reading.
    pub fn seek_to(&mut self, position: u64) -> std::io::Result<u64> {
        self.file.seek(SeekFrom::Start(position))
    }

    /// Truncate segment at the given position.
    ///
    /// Used during recovery to remove partial records.
    pub fn truncate(&mut self, position: u64) -> std::io::Result<()> {
        if self.closed {
            return Err(std::io::Error::new(
                std::io::ErrorKind::PermissionDenied,
                "Cannot truncate closed segment",
            ));
        }

        self.file.set_len(position)?;
        self.write_position = position;
        self.file.seek(SeekFrom::Start(position))?;
        Ok(())
    }
}

/// WAL record for a committed transaction.
///
/// Each record is self-delimiting with a length prefix and CRC32 checksum.
/// Records are immutable once written.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct WalRecord {
    /// Transaction ID (assigned by engine, NOT by storage)
    pub txn_id: u64,

    /// Run this transaction belongs to (UUID bytes)
    pub branch_id: [u8; 16],

    /// Commit timestamp (microseconds since epoch)
    pub timestamp: u64,

    /// Serialized writeset (codec-encoded)
    pub writeset: Vec<u8>,
}

impl WalRecord {
    /// Create a new WAL record.
    pub fn new(txn_id: u64, branch_id: [u8; 16], timestamp: u64, writeset: Vec<u8>) -> Self {
        WalRecord {
            txn_id,
            branch_id,
            timestamp,
            writeset,
        }
    }

    /// Serialize record to bytes (for writing to WAL).
    ///
    /// Format: length (4) + format_version (1) + payload + crc32 (4)
    ///
    /// The length field contains the size of (format_version + payload + crc32).
    pub fn to_bytes(&self) -> Vec<u8> {
        // Build payload: format_version + txn_id + branch_id + timestamp + writeset
        let mut payload = Vec::with_capacity(33 + self.writeset.len());
        payload.push(WAL_RECORD_FORMAT_VERSION);
        payload.extend_from_slice(&self.txn_id.to_le_bytes());
        payload.extend_from_slice(&self.branch_id);
        payload.extend_from_slice(&self.timestamp.to_le_bytes());
        payload.extend_from_slice(&self.writeset);

        // Calculate CRC32 of payload
        let crc = Self::compute_crc(&payload);

        // Build final record: length + payload + crc
        let total_len = payload.len() + 4; // payload + crc
        let mut record = Vec::with_capacity(4 + total_len);
        record.extend_from_slice(&(total_len as u32).to_le_bytes());
        record.extend_from_slice(&payload);
        record.extend_from_slice(&crc.to_le_bytes());

        record
    }

    /// Deserialize record from bytes.
    ///
    /// Returns (record, bytes_consumed) on success.
    pub fn from_bytes(bytes: &[u8]) -> Result<(Self, usize), WalRecordError> {
        if bytes.len() < 4 {
            return Err(WalRecordError::InsufficientData);
        }

        // Read length
        let length = u32::from_le_bytes(bytes[0..4].try_into().unwrap()) as usize;

        if length == 0 {
            return Err(WalRecordError::InvalidFormat);
        }

        if bytes.len() < 4 + length {
            return Err(WalRecordError::InsufficientData);
        }

        let payload_with_crc = &bytes[4..4 + length];

        if length < 5 {
            // Minimum: 1 byte format version + 4 bytes CRC
            return Err(WalRecordError::InvalidFormat);
        }

        // Split payload and CRC
        let payload = &payload_with_crc[..length - 4];
        let stored_crc = u32::from_le_bytes(payload_with_crc[length - 4..].try_into().unwrap());

        // Verify CRC
        let computed_crc = Self::compute_crc(payload);
        if computed_crc != stored_crc {
            return Err(WalRecordError::ChecksumMismatch {
                expected: stored_crc,
                computed: computed_crc,
            });
        }

        // Parse payload
        // Minimum payload size: 1 (version) + 8 (txn_id) + 16 (branch_id) + 8 (timestamp) = 33
        if payload.len() < 33 {
            return Err(WalRecordError::InvalidFormat);
        }

        let format_version = payload[0];
        if format_version != WAL_RECORD_FORMAT_VERSION {
            return Err(WalRecordError::UnsupportedVersion(format_version));
        }

        let txn_id = u64::from_le_bytes(payload[1..9].try_into().unwrap());
        let branch_id: [u8; 16] = payload[9..25].try_into().unwrap();
        let timestamp = u64::from_le_bytes(payload[25..33].try_into().unwrap());
        let writeset = payload[33..].to_vec();

        let record = WalRecord {
            txn_id,
            branch_id,
            timestamp,
            writeset,
        };

        Ok((record, 4 + length))
    }

    /// Compute CRC32 checksum of data.
    fn compute_crc(data: &[u8]) -> u32 {
        let mut hasher = Hasher::new();
        hasher.update(data);
        hasher.finalize()
    }

    /// Verify the checksum of serialized record bytes.
    pub fn verify_checksum(bytes: &[u8]) -> Result<(), WalRecordError> {
        if bytes.len() < 4 {
            return Err(WalRecordError::InsufficientData);
        }

        let length = u32::from_le_bytes(bytes[0..4].try_into().unwrap()) as usize;

        if bytes.len() < 4 + length || length < 5 {
            return Err(WalRecordError::InsufficientData);
        }

        let payload = &bytes[4..4 + length - 4];
        let stored_crc = u32::from_le_bytes(bytes[4 + length - 4..4 + length].try_into().unwrap());
        let computed_crc = Self::compute_crc(payload);

        if computed_crc != stored_crc {
            return Err(WalRecordError::ChecksumMismatch {
                expected: stored_crc,
                computed: computed_crc,
            });
        }

        Ok(())
    }
}

/// WAL record parsing errors.
#[derive(Debug, Clone, PartialEq, Eq, thiserror::Error)]
pub enum WalRecordError {
    /// Not enough data to parse record
    #[error("Insufficient data to parse record")]
    InsufficientData,

    /// Record format is invalid
    #[error("Invalid record format")]
    InvalidFormat,

    /// Checksum verification failed
    #[error("Checksum mismatch: expected {expected:08x}, computed {computed:08x}")]
    ChecksumMismatch {
        /// Expected checksum from record
        expected: u32,
        /// Computed checksum
        computed: u32,
    },

    /// Unsupported format version
    #[error("Unsupported format version: {0}")]
    UnsupportedVersion(u8),
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::tempdir;

    #[test]
    fn test_segment_header_roundtrip() {
        let header = SegmentHeader::new(12345, [0xAB; 16]);

        let bytes = header.to_bytes();
        let parsed = SegmentHeader::from_bytes(&bytes).unwrap();

        assert_eq!(parsed.magic, SEGMENT_MAGIC);
        assert_eq!(parsed.format_version, SEGMENT_FORMAT_VERSION);
        assert_eq!(parsed.segment_number, 12345);
        assert_eq!(parsed.database_uuid, [0xAB; 16]);
        assert!(parsed.is_valid());
    }

    #[test]
    fn test_segment_header_invalid_magic() {
        let mut header = SegmentHeader::new(1, [0; 16]);
        header.magic = *b"XXXX";
        assert!(!header.is_valid());
    }

    #[test]
    fn test_segment_path_format() {
        let dir = Path::new("/tmp/wal");
        assert_eq!(
            WalSegment::segment_path(dir, 1),
            PathBuf::from("/tmp/wal/wal-000001.seg")
        );
        assert_eq!(
            WalSegment::segment_path(dir, 999999),
            PathBuf::from("/tmp/wal/wal-999999.seg")
        );
    }

    #[test]
    fn test_segment_create_and_open() {
        let dir = tempdir().unwrap();
        let uuid = [1u8; 16];

        // Create segment
        let segment = WalSegment::create(dir.path(), 1, uuid).unwrap();
        assert_eq!(segment.segment_number(), 1);
        assert_eq!(segment.size(), SEGMENT_HEADER_SIZE as u64);
        assert!(!segment.is_closed());
        assert_eq!(segment.database_uuid(), uuid);
        drop(segment);

        // Open for reading
        let segment = WalSegment::open_read(dir.path(), 1).unwrap();
        assert_eq!(segment.segment_number(), 1);
        assert!(segment.is_closed());
    }

    #[test]
    fn test_segment_write_and_close() {
        let dir = tempdir().unwrap();
        let uuid = [2u8; 16];

        let mut segment = WalSegment::create(dir.path(), 1, uuid).unwrap();
        let initial_size = segment.size();

        segment.write(b"test data").unwrap();
        assert_eq!(segment.size(), initial_size + 9);

        segment.close().unwrap();
        assert!(segment.is_closed());

        // Cannot write to closed segment
        let result = segment.write(b"more data");
        assert!(result.is_err());
    }

    #[test]
    fn test_wal_record_roundtrip() {
        let record = WalRecord::new(42, [1u8; 16], 1234567890, vec![1, 2, 3, 4, 5]);

        let bytes = record.to_bytes();
        let (parsed, consumed) = WalRecord::from_bytes(&bytes).unwrap();

        assert_eq!(parsed.txn_id, 42);
        assert_eq!(parsed.branch_id, [1u8; 16]);
        assert_eq!(parsed.timestamp, 1234567890);
        assert_eq!(parsed.writeset, vec![1, 2, 3, 4, 5]);
        assert_eq!(consumed, bytes.len());
    }

    #[test]
    fn test_wal_record_empty_writeset() {
        let record = WalRecord::new(1, [0u8; 16], 0, Vec::new());

        let bytes = record.to_bytes();
        let (parsed, _) = WalRecord::from_bytes(&bytes).unwrap();

        assert!(parsed.writeset.is_empty());
    }

    #[test]
    fn test_wal_record_checksum_failure() {
        let record = WalRecord::new(42, [1u8; 16], 1234567890, vec![1, 2, 3]);

        let mut bytes = record.to_bytes();

        // Corrupt a byte in the payload
        bytes[10] ^= 0xFF;

        let result = WalRecord::from_bytes(&bytes);
        assert!(matches!(
            result,
            Err(WalRecordError::ChecksumMismatch { .. })
        ));
    }

    #[test]
    fn test_wal_record_insufficient_data() {
        // Too short for length field
        let result = WalRecord::from_bytes(&[1, 2, 3]);
        assert!(matches!(result, Err(WalRecordError::InsufficientData)));

        // Length says more data than available
        let result = WalRecord::from_bytes(&[100, 0, 0, 0, 1, 2, 3]);
        assert!(matches!(result, Err(WalRecordError::InsufficientData)));
    }

    #[test]
    fn test_wal_record_verify_checksum() {
        let record = WalRecord::new(1, [0u8; 16], 123, vec![1, 2, 3]);
        let bytes = record.to_bytes();

        assert!(WalRecord::verify_checksum(&bytes).is_ok());

        let mut corrupted = bytes.clone();
        corrupted[10] ^= 0xFF;
        assert!(WalRecord::verify_checksum(&corrupted).is_err());
    }

    #[test]
    fn test_multiple_records_in_sequence() {
        let records = vec![
            WalRecord::new(1, [1u8; 16], 100, vec![1, 2, 3]),
            WalRecord::new(2, [2u8; 16], 200, vec![4, 5, 6, 7]),
            WalRecord::new(3, [3u8; 16], 300, vec![]),
        ];

        // Serialize all records
        let mut all_bytes = Vec::new();
        for record in &records {
            all_bytes.extend_from_slice(&record.to_bytes());
        }

        // Parse them back
        let mut offset = 0;
        for expected in &records {
            let (parsed, consumed) = WalRecord::from_bytes(&all_bytes[offset..]).unwrap();
            assert_eq!(parsed.txn_id, expected.txn_id);
            assert_eq!(parsed.branch_id, expected.branch_id);
            assert_eq!(parsed.timestamp, expected.timestamp);
            assert_eq!(parsed.writeset, expected.writeset);
            offset += consumed;
        }

        assert_eq!(offset, all_bytes.len());
    }
}
