//! Core search types for M6 Retrieval Surfaces
//!
//! This module defines the foundational search types used throughout M6:
//! - SearchRequest: Universal request type for all search APIs
//! - SearchBudget: Time and candidate limits for search execution
//! - SearchResponse: Results from any search operation
//! - SearchHit: Individual search result with score and rank
//! - SearchStats: Execution statistics for debugging/monitoring
//! - DocRef: Back-pointer to source record in any primitive
//! - PrimitiveKind: Enumeration of all searchable primitives
//!
//! These types define the interface contracts for search operations.
//! See `docs/architecture/M6_ARCHITECTURE.md` for authoritative specification.

use crate::types::{JsonDocId, Key, RunId};
use std::collections::HashMap;

// ============================================================================
// PrimitiveKind (Story #307)
// ============================================================================

/// Enumeration of all searchable primitives
///
/// This enum identifies which primitive a search result comes from,
/// enabling per-primitive filtering and statistics tracking.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PrimitiveKind {
    /// Key-Value store
    Kv,
    /// JSON document store
    Json,
    /// Event log
    Event,
    /// State cell
    State,
    /// Trace store (reasoning logs)
    Trace,
    /// Run index
    Run,
    /// Vector store (M8)
    Vector,
}

impl PrimitiveKind {
    /// Returns all primitive kinds
    ///
    /// Useful for iterating over all primitives in composite search.
    pub fn all() -> &'static [PrimitiveKind] {
        &[
            PrimitiveKind::Kv,
            PrimitiveKind::Json,
            PrimitiveKind::Event,
            PrimitiveKind::State,
            PrimitiveKind::Trace,
            PrimitiveKind::Run,
            PrimitiveKind::Vector,
        ]
    }
}

impl std::fmt::Display for PrimitiveKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PrimitiveKind::Kv => write!(f, "kv"),
            PrimitiveKind::Json => write!(f, "json"),
            PrimitiveKind::Event => write!(f, "event"),
            PrimitiveKind::State => write!(f, "state"),
            PrimitiveKind::Trace => write!(f, "trace"),
            PrimitiveKind::Run => write!(f, "run"),
            PrimitiveKind::Vector => write!(f, "vector"),
        }
    }
}

// ============================================================================
// DocRef (Story #306)
// ============================================================================

/// Reference back to source record
///
/// Every search hit contains a DocRef that can be used to retrieve
/// the actual data from the appropriate primitive. This is the
/// back-pointer model that avoids data duplication.
///
/// # Invariant
///
/// DocRef MUST have a variant for every searchable primitive.
/// When a new primitive is added, DocRef MUST be extended.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DocRef {
    /// KV store entry
    Kv {
        /// Key of the KV entry
        key: Key,
    },

    /// JSON document
    Json {
        /// Key of the JSON collection
        key: Key,
        /// Document ID within the collection
        doc_id: JsonDocId,
    },

    /// Event log entry
    Event {
        /// Key of the event log
        log_key: Key,
        /// Sequence number within the log
        seq: u64,
    },

    /// State cell
    State {
        /// Key of the state cell
        key: Key,
    },

    /// Trace span
    Trace {
        /// Key of the trace store
        key: Key,
        /// Span ID within the trace
        span_id: u64,
    },

    /// Run metadata
    Run {
        /// Run ID
        run_id: RunId,
    },

    /// Vector entry (M8)
    Vector {
        /// Collection name
        collection: String,
        /// Vector key within collection
        key: String,
        /// Run ID for isolation
        run_id: RunId,
    },
}

impl DocRef {
    /// Get the primitive kind for this reference
    pub fn primitive_kind(&self) -> PrimitiveKind {
        match self {
            DocRef::Kv { .. } => PrimitiveKind::Kv,
            DocRef::Json { .. } => PrimitiveKind::Json,
            DocRef::Event { .. } => PrimitiveKind::Event,
            DocRef::State { .. } => PrimitiveKind::State,
            DocRef::Trace { .. } => PrimitiveKind::Trace,
            DocRef::Run { .. } => PrimitiveKind::Run,
            DocRef::Vector { .. } => PrimitiveKind::Vector,
        }
    }

    /// Get the run_id this reference belongs to
    pub fn run_id(&self) -> RunId {
        match self {
            DocRef::Kv { key } => key.namespace.run_id,
            DocRef::Json { key, .. } => key.namespace.run_id,
            DocRef::Event { log_key, .. } => log_key.namespace.run_id,
            DocRef::State { key } => key.namespace.run_id,
            DocRef::Trace { key, .. } => key.namespace.run_id,
            DocRef::Run { run_id } => *run_id,
            DocRef::Vector { run_id, .. } => *run_id,
        }
    }

    /// Create a vector document reference
    pub fn vector(run_id: RunId, collection: impl Into<String>, key: impl Into<String>) -> Self {
        DocRef::Vector {
            collection: collection.into(),
            key: key.into(),
            run_id,
        }
    }

    /// Check if this is a vector reference
    pub fn is_vector(&self) -> bool {
        matches!(self, DocRef::Vector { .. })
    }
}

// ============================================================================
// SearchBudget (Story #303)
// ============================================================================

/// Limits on search execution
///
/// Search operations respect these limits and return truncated
/// results rather than timing out or erroring. This provides
/// predictable latency and graceful degradation.
///
/// # Default Values
///
/// - max_wall_time_micros: 100,000 (100ms)
/// - max_candidates: 10,000
/// - max_candidates_per_primitive: 2,000
#[derive(Debug, Clone, Copy)]
pub struct SearchBudget {
    /// Hard stop on wall time (microseconds)
    pub max_wall_time_micros: u64,

    /// Maximum total candidates to consider
    pub max_candidates: usize,

    /// Maximum candidates per primitive (for composite search)
    pub max_candidates_per_primitive: usize,
}

impl Default for SearchBudget {
    fn default() -> Self {
        SearchBudget {
            max_wall_time_micros: 100_000, // 100ms
            max_candidates: 10_000,
            max_candidates_per_primitive: 2_000,
        }
    }
}

impl SearchBudget {
    /// Create a new SearchBudget with custom limits
    pub fn new(max_time_micros: u64, max_candidates: usize) -> Self {
        SearchBudget {
            max_wall_time_micros: max_time_micros,
            max_candidates,
            max_candidates_per_primitive: max_candidates / 6, // Split across 6 primitives
        }
    }

    /// Builder: set max wall time
    pub fn with_time(mut self, micros: u64) -> Self {
        self.max_wall_time_micros = micros;
        self
    }

    /// Builder: set max candidates
    pub fn with_candidates(mut self, max: usize) -> Self {
        self.max_candidates = max;
        self
    }

    /// Builder: set max candidates per primitive
    pub fn with_per_primitive(mut self, max: usize) -> Self {
        self.max_candidates_per_primitive = max;
        self
    }
}

// ============================================================================
// SearchMode (Story #302)
// ============================================================================

/// Search mode - determines the search strategy
///
/// M6 implements Keyword mode. Vector and Hybrid are reserved
/// for future milestones (M9+).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SearchMode {
    /// Keyword-based search using BM25-lite (M6 default)
    #[default]
    Keyword,
    /// Reserved for future vector search (M9)
    Vector,
    /// Reserved for future hybrid search (keyword + vector)
    Hybrid,
}

// ============================================================================
// SearchRequest (Story #302)
// ============================================================================

/// Request for search across primitives
///
/// This is the universal search request type used by both
/// primitive-level search (e.g., `kv.search()`) and composite
/// search (e.g., `db.hybrid().search()`).
///
/// # Invariant
///
/// The same SearchRequest type is used for all search operations.
/// This invariant must not change.
///
/// # Examples
///
/// ```
/// use in_mem_core::{SearchRequest, SearchBudget, RunId};
///
/// let run_id = RunId::new();
/// let req = SearchRequest::new(run_id, "authentication error")
///     .with_k(20)
///     .with_budget(SearchBudget::default().with_time(50_000));
///
/// assert_eq!(req.query, "authentication error");
/// assert_eq!(req.k, 20);
/// ```
#[derive(Debug, Clone)]
pub struct SearchRequest {
    /// Run to search within
    pub run_id: RunId,

    /// Query string (interpreted by scorer)
    pub query: String,

    /// Maximum results to return (top-k)
    pub k: usize,

    /// Time and work limits
    pub budget: SearchBudget,

    /// Search mode (Keyword, Vector, Hybrid)
    pub mode: SearchMode,

    /// Optional: limit to specific primitives (for composite search)
    pub primitive_filter: Option<Vec<PrimitiveKind>>,

    /// Optional: time range filter (microseconds since epoch)
    pub time_range: Option<(u64, u64)>,

    /// Optional: tag filter (match any)
    pub tags_any: Vec<String>,
}

impl SearchRequest {
    /// Create a new SearchRequest with defaults
    ///
    /// Default values:
    /// - k: 10
    /// - budget: SearchBudget::default()
    /// - mode: SearchMode::Keyword
    /// - primitive_filter: None (search all primitives)
    /// - time_range: None
    /// - tags_any: empty
    pub fn new(run_id: RunId, query: impl Into<String>) -> Self {
        SearchRequest {
            run_id,
            query: query.into(),
            k: 10,
            budget: SearchBudget::default(),
            mode: SearchMode::default(),
            primitive_filter: None,
            time_range: None,
            tags_any: vec![],
        }
    }

    /// Builder: set top-k results count
    pub fn with_k(mut self, k: usize) -> Self {
        self.k = k;
        self
    }

    /// Builder: set search budget
    pub fn with_budget(mut self, budget: SearchBudget) -> Self {
        self.budget = budget;
        self
    }

    /// Builder: set search mode
    pub fn with_mode(mut self, mode: SearchMode) -> Self {
        self.mode = mode;
        self
    }

    /// Builder: set primitive filter
    pub fn with_primitive_filter(mut self, filter: Vec<PrimitiveKind>) -> Self {
        self.primitive_filter = Some(filter);
        self
    }

    /// Builder: set time range filter
    pub fn with_time_range(mut self, start: u64, end: u64) -> Self {
        self.time_range = Some((start, end));
        self
    }

    /// Builder: set tags filter
    pub fn with_tags(mut self, tags: Vec<String>) -> Self {
        self.tags_any = tags;
        self
    }

    /// Check if a primitive is included in this request
    pub fn includes_primitive(&self, kind: PrimitiveKind) -> bool {
        match &self.primitive_filter {
            Some(filter) => filter.contains(&kind),
            None => true, // No filter means include all
        }
    }
}

// ============================================================================
// SearchHit (Story #305)
// ============================================================================

/// A single search result
///
/// Contains a back-pointer to the source record (DocRef),
/// the score from the scorer, and the rank in the result set.
#[derive(Debug, Clone)]
pub struct SearchHit {
    /// Back-pointer to source record
    pub doc_ref: DocRef,

    /// Score from scorer (higher = more relevant)
    pub score: f32,

    /// Rank in result set (1-indexed)
    pub rank: u32,

    /// Optional snippet for display
    pub snippet: Option<String>,
}

impl SearchHit {
    /// Create a new SearchHit
    pub fn new(doc_ref: DocRef, score: f32, rank: u32) -> Self {
        SearchHit {
            doc_ref,
            score,
            rank,
            snippet: None,
        }
    }

    /// Builder: set snippet
    pub fn with_snippet(mut self, snippet: String) -> Self {
        self.snippet = Some(snippet);
        self
    }
}

// ============================================================================
// SearchStats (Story #305)
// ============================================================================

/// Execution statistics for a search
///
/// Provides metadata about how the search was executed,
/// useful for debugging and monitoring.
#[derive(Debug, Clone, Default)]
pub struct SearchStats {
    /// Time spent in search (microseconds)
    pub elapsed_micros: u64,

    /// Total candidates considered
    pub candidates_considered: usize,

    /// Candidates per primitive (for composite search)
    pub candidates_by_primitive: HashMap<PrimitiveKind, usize>,

    /// Whether an index was used (vs. full scan)
    pub index_used: bool,
}

impl SearchStats {
    /// Create new SearchStats
    pub fn new(elapsed_micros: u64, candidates: usize) -> Self {
        SearchStats {
            elapsed_micros,
            candidates_considered: candidates,
            candidates_by_primitive: HashMap::new(),
            index_used: false,
        }
    }

    /// Builder: set index_used flag
    pub fn with_index_used(mut self, used: bool) -> Self {
        self.index_used = used;
        self
    }

    /// Add candidates count for a primitive
    pub fn add_primitive_candidates(&mut self, kind: PrimitiveKind, count: usize) {
        self.candidates_by_primitive.insert(kind, count);
        self.candidates_considered += count;
    }
}

// ============================================================================
// SearchResponse (Story #304)
// ============================================================================

/// Search results
///
/// Returned by both primitive-level and composite search.
/// Contains ranked hits plus execution metadata.
///
/// # Invariant
///
/// All search methods return SearchResponse. No primitive-specific
/// result types. This invariant must not change.
#[derive(Debug, Clone)]
pub struct SearchResponse {
    /// Ranked hits (highest score first)
    pub hits: Vec<SearchHit>,

    /// True if budget caused early termination
    pub truncated: bool,

    /// Execution statistics
    pub stats: SearchStats,
}

impl SearchResponse {
    /// Create an empty response
    pub fn empty() -> Self {
        SearchResponse {
            hits: vec![],
            truncated: false,
            stats: SearchStats::default(),
        }
    }

    /// Create a new response
    pub fn new(hits: Vec<SearchHit>, truncated: bool, stats: SearchStats) -> Self {
        SearchResponse {
            hits,
            truncated,
            stats,
        }
    }

    /// Check if response has no hits
    pub fn is_empty(&self) -> bool {
        self.hits.is_empty()
    }

    /// Get number of hits
    pub fn len(&self) -> usize {
        self.hits.len()
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Namespace;

    // ========================================
    // PrimitiveKind Tests
    // ========================================

    #[test]
    fn test_primitive_kind_all() {
        let all = PrimitiveKind::all();
        assert_eq!(all.len(), 7);
        assert!(all.contains(&PrimitiveKind::Kv));
        assert!(all.contains(&PrimitiveKind::Json));
        assert!(all.contains(&PrimitiveKind::Event));
        assert!(all.contains(&PrimitiveKind::State));
        assert!(all.contains(&PrimitiveKind::Trace));
        assert!(all.contains(&PrimitiveKind::Run));
        assert!(all.contains(&PrimitiveKind::Vector));
    }

    #[test]
    fn test_primitive_kind_display() {
        assert_eq!(format!("{}", PrimitiveKind::Kv), "kv");
        assert_eq!(format!("{}", PrimitiveKind::Json), "json");
        assert_eq!(format!("{}", PrimitiveKind::Event), "event");
        assert_eq!(format!("{}", PrimitiveKind::State), "state");
        assert_eq!(format!("{}", PrimitiveKind::Trace), "trace");
        assert_eq!(format!("{}", PrimitiveKind::Run), "run");
        assert_eq!(format!("{}", PrimitiveKind::Vector), "vector");
    }

    #[test]
    fn test_primitive_kind_copy() {
        let kind = PrimitiveKind::Kv;
        let kind2 = kind; // Copy
        assert_eq!(kind, kind2);
    }

    #[test]
    fn test_primitive_kind_hash() {
        use std::collections::HashSet;

        let mut set = HashSet::new();
        for kind in PrimitiveKind::all() {
            set.insert(*kind);
        }
        assert_eq!(set.len(), 7, "All PrimitiveKinds should be unique");
    }

    // ========================================
    // DocRef Tests
    // ========================================

    #[test]
    fn test_doc_ref_primitive_kind() {
        let run_id = RunId::new();
        let ns = Namespace::for_run(run_id);

        let kv_ref = DocRef::Kv {
            key: Key::new_kv(ns.clone(), "test"),
        };
        assert_eq!(kv_ref.primitive_kind(), PrimitiveKind::Kv);

        let json_ref = DocRef::Json {
            key: Key::new_json(ns.clone(), &JsonDocId::new()),
            doc_id: JsonDocId::new(),
        };
        assert_eq!(json_ref.primitive_kind(), PrimitiveKind::Json);

        let event_ref = DocRef::Event {
            log_key: Key::new_event(ns.clone(), 0),
            seq: 42,
        };
        assert_eq!(event_ref.primitive_kind(), PrimitiveKind::Event);

        let state_ref = DocRef::State {
            key: Key::new_state(ns.clone(), "cell"),
        };
        assert_eq!(state_ref.primitive_kind(), PrimitiveKind::State);

        let trace_ref = DocRef::Trace {
            key: Key::new_trace(ns.clone(), 0),
            span_id: 123,
        };
        assert_eq!(trace_ref.primitive_kind(), PrimitiveKind::Trace);

        let run_ref = DocRef::Run { run_id };
        assert_eq!(run_ref.primitive_kind(), PrimitiveKind::Run);
    }

    #[test]
    fn test_doc_ref_run_id() {
        let run_id = RunId::new();
        let ns = Namespace::for_run(run_id);

        let kv_ref = DocRef::Kv {
            key: Key::new_kv(ns.clone(), "test"),
        };
        assert_eq!(kv_ref.run_id(), run_id);

        let run_ref = DocRef::Run { run_id };
        assert_eq!(run_ref.run_id(), run_id);
    }

    #[test]
    fn test_doc_ref_equality() {
        let run_id = RunId::new();
        let ns = Namespace::for_run(run_id);
        let key = Key::new_kv(ns.clone(), "test");

        let ref1 = DocRef::Kv { key: key.clone() };
        let ref2 = DocRef::Kv { key: key.clone() };

        assert_eq!(ref1, ref2);
    }

    #[test]
    fn test_doc_ref_hash() {
        use std::collections::HashSet;

        let run_id = RunId::new();
        let ns = Namespace::for_run(run_id);

        let ref1 = DocRef::Kv {
            key: Key::new_kv(ns.clone(), "key1"),
        };
        let ref2 = DocRef::Kv {
            key: Key::new_kv(ns.clone(), "key2"),
        };

        let mut set = HashSet::new();
        set.insert(ref1.clone());
        set.insert(ref2.clone());

        assert_eq!(set.len(), 2);
        assert!(set.contains(&ref1));
        assert!(set.contains(&ref2));
    }

    // ========================================
    // SearchBudget Tests
    // ========================================

    #[test]
    fn test_search_budget_defaults() {
        let budget = SearchBudget::default();

        assert_eq!(budget.max_wall_time_micros, 100_000);
        assert_eq!(budget.max_candidates, 10_000);
        assert_eq!(budget.max_candidates_per_primitive, 2_000);
    }

    #[test]
    fn test_search_budget_builder() {
        let budget = SearchBudget::default()
            .with_time(50_000)
            .with_candidates(5_000)
            .with_per_primitive(1_000);

        assert_eq!(budget.max_wall_time_micros, 50_000);
        assert_eq!(budget.max_candidates, 5_000);
        assert_eq!(budget.max_candidates_per_primitive, 1_000);
    }

    #[test]
    fn test_search_budget_new() {
        let budget = SearchBudget::new(200_000, 20_000);

        assert_eq!(budget.max_wall_time_micros, 200_000);
        assert_eq!(budget.max_candidates, 20_000);
        // 20_000 / 6 = 3_333
        assert_eq!(budget.max_candidates_per_primitive, 3_333);
    }

    // ========================================
    // SearchMode Tests
    // ========================================

    #[test]
    fn test_search_mode_default() {
        let mode = SearchMode::default();
        assert_eq!(mode, SearchMode::Keyword);
    }

    #[test]
    fn test_search_mode_variants() {
        let _keyword = SearchMode::Keyword;
        let _vector = SearchMode::Vector;
        let _hybrid = SearchMode::Hybrid;
    }

    // ========================================
    // SearchRequest Tests
    // ========================================

    #[test]
    fn test_search_request_new() {
        let run_id = RunId::new();
        let req = SearchRequest::new(run_id, "test query");

        assert_eq!(req.run_id, run_id);
        assert_eq!(req.query, "test query");
        assert_eq!(req.k, 10);
        assert_eq!(req.mode, SearchMode::Keyword);
        assert!(req.primitive_filter.is_none());
        assert!(req.time_range.is_none());
        assert!(req.tags_any.is_empty());
    }

    #[test]
    fn test_search_request_builder() {
        let run_id = RunId::new();
        let req = SearchRequest::new(run_id, "test query")
            .with_k(20)
            .with_budget(SearchBudget::default().with_time(50_000))
            .with_mode(SearchMode::Keyword)
            .with_primitive_filter(vec![PrimitiveKind::Kv, PrimitiveKind::Json])
            .with_time_range(1000, 2000)
            .with_tags(vec!["important".to_string()]);

        assert_eq!(req.k, 20);
        assert_eq!(req.budget.max_wall_time_micros, 50_000);
        assert_eq!(
            req.primitive_filter,
            Some(vec![PrimitiveKind::Kv, PrimitiveKind::Json])
        );
        assert_eq!(req.time_range, Some((1000, 2000)));
        assert_eq!(req.tags_any, vec!["important".to_string()]);
    }

    #[test]
    fn test_search_request_includes_primitive() {
        let run_id = RunId::new();

        // No filter - includes all
        let req1 = SearchRequest::new(run_id, "test");
        assert!(req1.includes_primitive(PrimitiveKind::Kv));
        assert!(req1.includes_primitive(PrimitiveKind::Json));
        assert!(req1.includes_primitive(PrimitiveKind::Event));

        // With filter - only includes specified
        let req2 = SearchRequest::new(run_id, "test")
            .with_primitive_filter(vec![PrimitiveKind::Kv, PrimitiveKind::Json]);
        assert!(req2.includes_primitive(PrimitiveKind::Kv));
        assert!(req2.includes_primitive(PrimitiveKind::Json));
        assert!(!req2.includes_primitive(PrimitiveKind::Event));
        assert!(!req2.includes_primitive(PrimitiveKind::State));
    }

    // ========================================
    // SearchHit Tests
    // ========================================

    #[test]
    fn test_search_hit_new() {
        let run_id = RunId::new();
        let doc_ref = DocRef::Run { run_id };

        let hit = SearchHit::new(doc_ref.clone(), 0.95, 1);

        assert_eq!(hit.doc_ref, doc_ref);
        assert!((hit.score - 0.95).abs() < f32::EPSILON);
        assert_eq!(hit.rank, 1);
        assert!(hit.snippet.is_none());
    }

    #[test]
    fn test_search_hit_with_snippet() {
        let run_id = RunId::new();
        let doc_ref = DocRef::Run { run_id };

        let hit = SearchHit::new(doc_ref, 0.95, 1).with_snippet("matched text here".to_string());

        assert_eq!(hit.snippet, Some("matched text here".to_string()));
    }

    // ========================================
    // SearchStats Tests
    // ========================================

    #[test]
    fn test_search_stats_default() {
        let stats = SearchStats::default();

        assert_eq!(stats.elapsed_micros, 0);
        assert_eq!(stats.candidates_considered, 0);
        assert!(stats.candidates_by_primitive.is_empty());
        assert!(!stats.index_used);
    }

    #[test]
    fn test_search_stats_new() {
        let stats = SearchStats::new(1000, 500);

        assert_eq!(stats.elapsed_micros, 1000);
        assert_eq!(stats.candidates_considered, 500);
    }

    #[test]
    fn test_search_stats_builder() {
        let stats = SearchStats::new(1000, 500).with_index_used(true);

        assert!(stats.index_used);
    }

    #[test]
    fn test_search_stats_add_primitive_candidates() {
        let mut stats = SearchStats::default();

        stats.add_primitive_candidates(PrimitiveKind::Kv, 100);
        stats.add_primitive_candidates(PrimitiveKind::Json, 200);

        assert_eq!(stats.candidates_considered, 300);
        assert_eq!(
            stats.candidates_by_primitive.get(&PrimitiveKind::Kv),
            Some(&100)
        );
        assert_eq!(
            stats.candidates_by_primitive.get(&PrimitiveKind::Json),
            Some(&200)
        );
    }

    // ========================================
    // SearchResponse Tests
    // ========================================

    #[test]
    fn test_search_response_empty() {
        let response = SearchResponse::empty();

        assert!(response.is_empty());
        assert_eq!(response.len(), 0);
        assert!(!response.truncated);
    }

    #[test]
    fn test_search_response_new() {
        let run_id = RunId::new();
        let hits = vec![
            SearchHit::new(DocRef::Run { run_id }, 0.9, 1),
            SearchHit::new(DocRef::Run { run_id }, 0.8, 2),
        ];
        let stats = SearchStats::new(500, 100);

        let response = SearchResponse::new(hits, true, stats);

        assert_eq!(response.len(), 2);
        assert!(!response.is_empty());
        assert!(response.truncated);
        assert_eq!(response.stats.elapsed_micros, 500);
    }
}
