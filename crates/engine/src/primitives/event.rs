//! EventLog: Immutable append-only event stream primitive
//!
//! ## Role: Determinism Boundary Recorder
//!
//! EventLog records nondeterministic external inputs that cross the determinism boundary.
//! Its purpose is to enable deterministic replay of agent branches by capturing exactly
//! the information needed to reproduce nondeterministic behavior.
//!
//! Key invariant: If an operation's result is NOT recorded in EventLog, that operation
//! MUST be deterministic given the current state.
//!
//! ## Design Principles
//!
//! 1. **Single-Writer-Ordered**: All appends serialize through CAS on metadata key.
//!    Parallel append is NOT supported - event ordering must be total within a branch.
//!
//! 2. **Causal Hash Chaining**: Each event includes SHA-256 hash of previous event.
//!    Provides tamper-evidence and deterministic verification.
//!
//! 3. **Append-Only**: No update or delete operations - events are immutable.
//!
//! 4. **Object-Only Payloads**: All payloads must be JSON objects (not primitives/arrays).
//!
//! 5. **Global Sequences**: Streams are filters over a single global sequence per branch.
//!
//! ## Hash Chain
//!
//! Uses SHA-256 for deterministic cross-platform hashing. Hash version 1 computes:
//! SHA256(sequence || event_type_len || event_type || timestamp || payload_len || payload || prev_hash)
//!
//! ## Key Design
//!
//! - TypeTag: Event (0x02)
//! - Event key: `<namespace>:<TypeTag::Event>:<sequence_be_bytes>`
//! - Metadata key: `<namespace>:<TypeTag::Event>:__meta__`

use crate::database::{Database, RetryConfig};
use crate::primitives::extensions::EventLogExt;
use serde::{Deserialize, Serialize};
use sha2::{Digest, Sha256};
use std::collections::HashMap;
use std::sync::Arc;
use strata_concurrency::TransactionContext;
use strata_core::contract::{Timestamp, Version, Versioned};
use strata_core::types::{BranchId, Key, Namespace};
use strata_core::value::Value;
use strata_core::StrataError;
use strata_core::StrataResult;

// Re-export Event from core
pub use strata_core::primitives::Event;

/// Hash version constants
pub(crate) const HASH_VERSION_SHA256: u8 = 1; // SHA-256

/// Per-stream metadata for O(1) access to stream statistics
///
/// Note: The `sequences` field was removed in #972 to fix O(N) metadata growth.
/// Per-type sequence lookups now use separate index keys (see `Key::new_event_type_idx`).
/// Old metadata with `sequences` will deserialize correctly (serde ignores unknown fields).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StreamMeta {
    /// Number of events in this stream
    pub count: u64,
    /// First sequence number in this stream (global sequence)
    pub first_sequence: u64,
    /// Last sequence number in this stream (global sequence)
    pub last_sequence: u64,
    /// Timestamp of first event in stream (microseconds since epoch)
    pub first_timestamp: u64,
    /// Timestamp of last event in stream (microseconds since epoch)
    pub last_timestamp: u64,
}

impl StreamMeta {
    fn new(sequence: u64, timestamp: u64) -> Self {
        Self {
            count: 1,
            first_sequence: sequence,
            last_sequence: sequence,
            first_timestamp: timestamp,
            last_timestamp: timestamp,
        }
    }

    fn update(&mut self, sequence: u64, timestamp: u64) {
        self.count += 1;
        self.last_sequence = sequence;
        self.last_timestamp = timestamp;
    }
}

/// EventLog metadata stored per branch
#[derive(Debug, Clone, Serialize, Deserialize)]
pub(crate) struct EventLogMeta {
    /// Next sequence number to assign
    pub next_sequence: u64,
    /// Hash of the last event (head of chain)
    pub head_hash: [u8; 32],
    /// Hash algorithm version (0 = legacy DefaultHasher, 1 = SHA-256)
    #[serde(default)]
    pub hash_version: u8,
    /// Per-stream metadata for O(1) stream queries
    #[serde(default)]
    pub streams: HashMap<String, StreamMeta>,
}

impl Default for EventLogMeta {
    fn default() -> Self {
        Self {
            next_sequence: 0,
            head_hash: [0u8; 32],
            hash_version: HASH_VERSION_SHA256, // New logs use SHA-256
            streams: HashMap::new(),
        }
    }
}

/// Compute event hash using SHA-256
///
/// Deterministic across platforms and Rust versions.
/// Format: SHA256(sequence || event_type_len || event_type || timestamp || payload_len || payload || prev_hash)
///
/// This is the canonical hash function for event chain integrity.
/// All code paths that compute event hashes MUST use this function.
pub fn compute_event_hash(
    sequence: u64,
    event_type: &str,
    payload: &Value,
    timestamp: u64,
    prev_hash: &[u8; 32],
) -> [u8; 32] {
    let mut hasher = Sha256::new();

    // Sequence (8 bytes, little-endian)
    hasher.update(&sequence.to_le_bytes());

    // Event type with length prefix (4 bytes length + content)
    hasher.update(&(event_type.len() as u32).to_le_bytes());
    hasher.update(event_type.as_bytes());

    // Timestamp (8 bytes, little-endian)
    hasher.update(&timestamp.to_le_bytes());

    // Payload as canonical JSON with length prefix
    let payload_bytes = serde_json::to_vec(payload).unwrap_or_default();
    hasher.update(&(payload_bytes.len() as u32).to_le_bytes());
    hasher.update(&payload_bytes);

    // Previous hash (32 bytes)
    hasher.update(prev_hash);

    hasher.finalize().into()
}

/// Validation error for EventLog operations
#[derive(Debug, Clone, PartialEq)]
pub enum EventLogValidationError {
    /// Payload must be an object, not a primitive or array
    PayloadNotObject,
    /// Payload contains NaN or Infinity which are not valid JSON
    PayloadContainsNonFiniteFloat,
    /// Event type cannot be empty
    EmptyEventType,
    /// Event type cannot exceed maximum length
    EventTypeTooLong(usize),
}

impl std::fmt::Display for EventLogValidationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::PayloadNotObject => write!(f, "payload must be a JSON object"),
            Self::PayloadContainsNonFiniteFloat => write!(f, "payload contains NaN or Infinity"),
            Self::EmptyEventType => write!(f, "event_type cannot be empty"),
            Self::EventTypeTooLong(len) => write!(f, "event_type exceeds maximum length ({})", len),
        }
    }
}

/// Maximum allowed event type length
const MAX_EVENT_TYPE_LENGTH: usize = 256;

/// Validate event type
fn validate_event_type(event_type: &str) -> std::result::Result<(), EventLogValidationError> {
    if event_type.is_empty() {
        return Err(EventLogValidationError::EmptyEventType);
    }
    if event_type.len() > MAX_EVENT_TYPE_LENGTH {
        return Err(EventLogValidationError::EventTypeTooLong(event_type.len()));
    }
    Ok(())
}

/// Validate payload is an object and contains no non-finite floats
fn validate_payload(payload: &Value) -> std::result::Result<(), EventLogValidationError> {
    // Payload must be an object
    if !matches!(payload, Value::Object(_)) {
        return Err(EventLogValidationError::PayloadNotObject);
    }

    // Check for non-finite floats recursively
    if contains_non_finite_float(payload) {
        return Err(EventLogValidationError::PayloadContainsNonFiniteFloat);
    }

    Ok(())
}

/// Check if a Value contains NaN or Infinity
fn contains_non_finite_float(value: &Value) -> bool {
    match value {
        Value::Float(f) => !f.is_finite(),
        Value::Object(map) => map.values().any(contains_non_finite_float),
        Value::Array(arr) => arr.iter().any(contains_non_finite_float),
        _ => false,
    }
}

/// Serialize a struct to Value::String for storage
fn to_stored_value<T: Serialize>(v: &T) -> StrataResult<Value> {
    serde_json::to_string(v)
        .map(Value::String)
        .map_err(|e| StrataError::serialization(e.to_string()))
}

/// Deserialize from Value::String storage
fn from_stored_value<T: for<'de> Deserialize<'de>>(
    v: &Value,
) -> std::result::Result<T, serde_json::Error> {
    match v {
        Value::String(s) => serde_json::from_str(s),
        _ => serde_json::from_str("null"), // Will fail with appropriate error
    }
}

/// Immutable append-only event stream
///
/// DESIGN: Single-writer-ordered per branch.
/// All appends serialize through CAS on metadata key.
///
/// # Example
///
/// ```ignore
/// use strata_primitives::EventLog;
/// use strata_engine::Database;
/// use strata_core::types::BranchId;
/// use strata_core::value::Value;
///
/// let db = Database::open("/path/to/data")?;
/// let log = EventLog::new(db);
/// let branch_id = BranchId::new();
///
/// // Append events
/// let (seq, hash) = log.append(&branch_id, "tool_call", Value::String("search".into()))?;
///
/// // Read events
/// let event = log.read(&branch_id, seq)?;
///
/// // Verify chain
/// let verification = log.verify_chain(&branch_id)?;
/// assert!(verification.is_valid);
/// ```
#[derive(Clone)]
pub struct EventLog {
    db: Arc<Database>,
}

impl EventLog {
    /// Create new EventLog instance
    pub fn new(db: Arc<Database>) -> Self {
        Self { db }
    }

    /// Get the underlying database reference
    pub fn database(&self) -> &Arc<Database> {
        &self.db
    }

    /// Build namespace for branch-scoped operations
    fn namespace_for_branch(&self, branch_id: &BranchId) -> Namespace {
        Namespace::for_branch(*branch_id)
    }

    // ========== Append Operation ==========

    /// Append a new event to the log
    ///
    /// Returns the assigned sequence version.
    /// Serializes through CAS on metadata key - parallel appends will retry
    /// automatically with exponential backoff.
    ///
    /// # Arguments
    /// * `branch_id` - The branch to append to
    /// * `event_type` - User-defined event category (non-empty, max 256 chars)
    /// * `payload` - Event data (must be a JSON object, no NaN/Infinity)
    ///
    /// # Returns
    /// Version::Sequence containing the assigned sequence number
    ///
    /// # Errors
    /// Returns error if:
    /// - `event_type` is empty or exceeds 256 characters
    /// - `payload` is not a JSON object
    /// - `payload` contains NaN or Infinity float values
    pub fn append(
        &self,
        branch_id: &BranchId,
        event_type: &str,
        payload: Value,
    ) -> StrataResult<Version> {
        // Validate inputs before entering transaction
        validate_event_type(event_type).map_err(|e| StrataError::invalid_input(e.to_string()))?;
        validate_payload(&payload).map_err(|e| StrataError::invalid_input(e.to_string()))?;

        // Use high retry count for contention scenarios
        // EventLog appends serialize through metadata CAS, so conflicts are expected
        // With N concurrent threads, worst case needs N retries per append
        // 200 retries with fast backoff handles 100+ concurrent threads reliably
        let retry_config = RetryConfig::default()
            .with_max_retries(50)
            .with_base_delay_ms(1)
            .with_max_delay_ms(50);

        let ns = self.namespace_for_branch(branch_id);
        let event_type_owned = event_type.to_string();

        let result = self
            .db
            .transaction_with_retry(*branch_id, retry_config, |txn| {
                // Read current metadata (or default)
                let meta_key = Key::new_event_meta(ns.clone());
                let mut meta: EventLogMeta = match txn.get(&meta_key)? {
                    Some(v) => from_stored_value(&v).unwrap_or_else(|_| EventLogMeta::default()),
                    None => EventLogMeta::default(),
                };

                // Compute event hash using current hash version
                let sequence = meta.next_sequence;
                let timestamp = std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_micros() as u64;

                let hash = compute_event_hash(
                    sequence,
                    &event_type_owned,
                    &payload,
                    timestamp,
                    &meta.head_hash,
                );

                // Build event
                let event = Event {
                    sequence,
                    event_type: event_type_owned.clone(),
                    payload: payload.clone(),
                    timestamp,
                    prev_hash: meta.head_hash,
                    hash,
                };

                // Write event
                let event_key = Key::new_event(ns.clone(), sequence);
                txn.put(event_key, to_stored_value(&event)?)?;

                // Write per-type index key for efficient read_by_type lookups (#972)
                let idx_key =
                    Key::new_event_type_idx(ns.clone(), &event_type_owned, sequence);
                txn.put(idx_key, Value::Null)?;

                // Update stream metadata
                match meta.streams.get_mut(&event_type_owned) {
                    Some(stream_meta) => stream_meta.update(sequence, timestamp),
                    None => {
                        meta.streams.insert(
                            event_type_owned.clone(),
                            StreamMeta::new(sequence, timestamp),
                        );
                    }
                }

                // Update metadata (CAS semantics through transaction)
                meta.next_sequence = sequence + 1;
                meta.head_hash = hash;
                txn.put(meta_key, to_stored_value(&meta)?)?;

                Ok(Version::Sequence(sequence))
            })?;

        // Update inverted index (zero overhead when disabled)
        let idx = self.db.extension::<crate::search::InvertedIndex>();
        if idx.is_enabled() {
            let text = format!(
                "{} {}",
                event_type,
                serde_json::to_string(&payload).unwrap_or_default()
            );
            if let Version::Sequence(seq) = result {
                let entity_ref = crate::search::EntityRef::Event {
                    branch_id: *branch_id,
                    sequence: seq,
                };
                idx.index_document(&entity_ref, &text, None);
            }
        }

        Ok(result)
    }

    // ========== Read Operations ==========

    /// Read a single event by sequence number.
    ///
    /// Returns Versioned<Event> if found.
    pub fn read(
        &self,
        branch_id: &BranchId,
        sequence: u64,
    ) -> StrataResult<Option<Versioned<Event>>> {
        self.db.transaction(*branch_id, |txn| {
            let ns = self.namespace_for_branch(branch_id);
            let event_key = Key::new_event(ns, sequence);

            match txn.get(&event_key)? {
                Some(v) => {
                    let event: Event = from_stored_value(&v)
                        .map_err(|e| strata_core::StrataError::serialization(e.to_string()))?;
                    Ok(Some(Versioned::with_timestamp(
                        event.clone(),
                        Version::Sequence(sequence),
                        Timestamp::from_micros(event.timestamp),
                    )))
                }
                None => Ok(None),
            }
        })
    }

    /// Get the current length of the log.
    pub fn len(&self, branch_id: &BranchId) -> StrataResult<u64> {
        self.db.transaction(*branch_id, |txn| {
            let ns = self.namespace_for_branch(branch_id);
            let meta_key = Key::new_event_meta(ns);

            let meta: EventLogMeta = match txn.get(&meta_key)? {
                Some(v) => from_stored_value(&v).unwrap_or_else(|_| EventLogMeta::default()),
                None => EventLogMeta::default(),
            };

            Ok(meta.next_sequence)
        })
    }

    // ========== Query by Type ==========

    /// Read events filtered by type
    ///
    /// Returns Vec<Versioned<Event>> for events matching the type.
    /// Uses per-type index keys for O(K) lookup where K = events of that type.
    pub fn read_by_type(
        &self,
        branch_id: &BranchId,
        event_type: &str,
    ) -> StrataResult<Vec<Versioned<Event>>> {
        self.db.transaction(*branch_id, |txn| {
            let ns = self.namespace_for_branch(branch_id);

            // Use per-type index keys for efficient lookup (#972)
            let idx_prefix = Key::new_event_type_idx_prefix(ns.clone(), event_type);
            let idx_entries = txn.scan_prefix(&idx_prefix)?;

            if !idx_entries.is_empty() {
                let mut results = Vec::with_capacity(idx_entries.len());
                for (idx_key, _) in &idx_entries {
                    // Extract sequence from the last 8 bytes of the user_key
                    let user_key = &idx_key.user_key;
                    if user_key.len() >= 8 {
                        let seq_bytes: [u8; 8] =
                            user_key[user_key.len() - 8..].try_into().unwrap();
                        let seq = u64::from_be_bytes(seq_bytes);
                        let event_key = Key::new_event(ns.clone(), seq);
                        if let Some(v) = txn.get(&event_key)? {
                            let event: Event = from_stored_value(&v).map_err(|e| {
                                strata_core::StrataError::serialization(e.to_string())
                            })?;
                            results.push(Versioned::with_timestamp(
                                event.clone(),
                                Version::Sequence(seq),
                                Timestamp::from_micros(event.timestamp),
                            ));
                        }
                    }
                }
                return Ok(results);
            }

            // Fallback: O(N) scan for old data without type index keys
            let meta_key = Key::new_event_meta(ns.clone());
            let meta: EventLogMeta = match txn.get(&meta_key)? {
                Some(v) => from_stored_value(&v).unwrap_or_else(|_| EventLogMeta::default()),
                None => return Ok(Vec::new()),
            };

            let mut filtered = Vec::new();
            for seq in 0..meta.next_sequence {
                let event_key = Key::new_event(ns.clone(), seq);
                if let Some(v) = txn.get(&event_key)? {
                    let event: Event = from_stored_value(&v)
                        .map_err(|e| strata_core::StrataError::serialization(e.to_string()))?;
                    if event.event_type == event_type {
                        filtered.push(Versioned::with_timestamp(
                            event.clone(),
                            Version::Sequence(seq),
                            Timestamp::from_micros(event.timestamp),
                        ));
                    }
                }
            }

            Ok(filtered)
        })
    }
}

// ========== Searchable Trait Implementation ==========

impl crate::search::Searchable for EventLog {
    fn search(
        &self,
        _req: &crate::SearchRequest,
    ) -> strata_core::StrataResult<crate::SearchResponse> {
        // Search is handled by the intelligence layer, not the primitive
        Ok(crate::SearchResponse::empty())
    }

    fn primitive_kind(&self) -> strata_core::PrimitiveType {
        strata_core::PrimitiveType::Event
    }
}

// ========== EventLogExt Implementation ==========

impl EventLogExt for TransactionContext {
    fn event_append(&mut self, event_type: &str, payload: Value) -> StrataResult<u64> {
        // Validate inputs
        validate_event_type(event_type).map_err(|e| StrataError::invalid_input(e.to_string()))?;
        validate_payload(&payload).map_err(|e| StrataError::invalid_input(e.to_string()))?;

        let ns = Namespace::for_branch(self.branch_id);

        // Read current metadata (or default)
        let meta_key = Key::new_event_meta(ns.clone());
        let mut meta: EventLogMeta = match self.get(&meta_key)? {
            Some(v) => from_stored_value(&v).unwrap_or_else(|_| EventLogMeta::default()),
            None => EventLogMeta::default(),
        };

        // Compute event hash using current hash version
        let sequence = meta.next_sequence;
        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_micros() as u64;

        let hash = compute_event_hash(sequence, event_type, &payload, timestamp, &meta.head_hash);

        // Build event
        let event = Event {
            sequence,
            event_type: event_type.to_string(),
            payload: payload.clone(),
            timestamp,
            prev_hash: meta.head_hash,
            hash,
        };

        // Write event
        let event_key = Key::new_event(ns.clone(), sequence);
        self.put(event_key, to_stored_value(&event)?)?;

        // Write per-type index key for efficient read_by_type lookups (#972)
        let idx_key = Key::new_event_type_idx(ns.clone(), event_type, sequence);
        self.put(idx_key, Value::Null)?;

        // Update stream metadata
        let event_type_owned = event_type.to_string();
        match meta.streams.get_mut(&event_type_owned) {
            Some(stream_meta) => stream_meta.update(sequence, timestamp),
            None => {
                meta.streams
                    .insert(event_type_owned, StreamMeta::new(sequence, timestamp));
            }
        }

        // Update metadata
        meta.next_sequence = sequence + 1;
        meta.head_hash = hash;
        self.put(meta_key, to_stored_value(&meta)?)?;

        Ok(sequence)
    }

    fn event_read(&mut self, sequence: u64) -> StrataResult<Option<Value>> {
        let ns = Namespace::for_branch(self.branch_id);
        let event_key = Key::new_event(ns, sequence);
        self.get(&event_key)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    fn setup() -> (TempDir, Arc<Database>, EventLog) {
        let temp_dir = TempDir::new().unwrap();
        let db = Database::open(temp_dir.path()).unwrap();
        let log = EventLog::new(db.clone());
        (temp_dir, db, log)
    }

    /// Helper to create an empty object payload
    fn empty_payload() -> Value {
        Value::Object(HashMap::new())
    }

    /// Helper to create an object payload with a single value
    fn payload_with(key: &str, value: Value) -> Value {
        Value::Object(HashMap::from([(key.to_string(), value)]))
    }

    /// Helper to create an object payload with an integer
    fn int_payload(v: i64) -> Value {
        payload_with("value", Value::Int(v))
    }

    // ========== Core Structure Tests ==========

    #[test]
    fn test_event_serialization() {
        let event = Event {
            sequence: 42,
            event_type: "test".to_string(),
            payload: payload_with("data", Value::String("test".into())),
            timestamp: 1234567890,
            prev_hash: [0u8; 32],
            hash: [1u8; 32],
        };

        let json = serde_json::to_string(&event).unwrap();
        let restored: Event = serde_json::from_str(&json).unwrap();
        assert_eq!(event, restored);
    }

    #[test]
    fn test_eventlog_meta_default() {
        let meta = EventLogMeta::default();
        assert_eq!(meta.next_sequence, 0);
        assert_eq!(meta.head_hash, [0u8; 32]);
        assert_eq!(meta.hash_version, HASH_VERSION_SHA256);
        assert!(meta.streams.is_empty());
    }

    #[test]
    fn test_eventlog_creation() {
        let (_temp, _db, log) = setup();
        assert!(Arc::strong_count(log.database()) >= 1);
    }

    #[test]
    fn test_eventlog_is_clone() {
        let (_temp, _db, log1) = setup();
        let log2 = log1.clone();
        assert!(Arc::ptr_eq(log1.database(), log2.database()));
    }

    #[test]
    fn test_eventlog_is_send_sync() {
        fn assert_send_sync<T: Send + Sync>() {}
        assert_send_sync::<EventLog>();
    }

    // ========== Validation Tests ==========

    #[test]
    fn test_validation_rejects_null_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let result = log.append(&branch_id, "test", Value::Null);
        assert!(result.is_err());
        let err = result.unwrap_err();
        assert!(err.to_string().contains("object"));
    }

    #[test]
    fn test_validation_rejects_primitive_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        // Test various primitive types
        assert!(log.append(&branch_id, "test", Value::Int(42)).is_err());
        assert!(log
            .append(&branch_id, "test", Value::String("hello".into()))
            .is_err());
        assert!(log.append(&branch_id, "test", Value::Bool(true)).is_err());
        assert!(log.append(&branch_id, "test", Value::Float(3.14)).is_err());
    }

    #[test]
    fn test_validation_rejects_array_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let result = log.append(&branch_id, "test", Value::Array(vec![Value::Int(1)]));
        assert!(result.is_err());
    }

    #[test]
    fn test_validation_rejects_nan_in_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let payload = payload_with("value", Value::Float(f64::NAN));
        let result = log.append(&branch_id, "test", payload);
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("NaN"));
    }

    #[test]
    fn test_validation_rejects_infinity_in_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let payload = payload_with("value", Value::Float(f64::INFINITY));
        let result = log.append(&branch_id, "test", payload);
        assert!(result.is_err());
    }

    #[test]
    fn test_validation_rejects_empty_event_type() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let result = log.append(&branch_id, "", empty_payload());
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("empty"));
    }

    #[test]
    fn test_validation_rejects_too_long_event_type() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let long_type = "x".repeat(MAX_EVENT_TYPE_LENGTH + 1);
        let result = log.append(&branch_id, &long_type, empty_payload());
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("length"));
    }

    #[test]
    fn test_validation_accepts_valid_object_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let payload = Value::Object(HashMap::from([
            ("tool".to_string(), Value::String("search".into())),
            ("count".to_string(), Value::Int(42)),
        ]));

        let result = log.append(&branch_id, "test", payload);
        assert!(result.is_ok());
    }

    // ========== Append Tests ==========

    #[test]
    fn test_append_first_event() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let version = log.append(&branch_id, "test", empty_payload()).unwrap();
        assert!(matches!(version, Version::Sequence(0)));
    }

    #[test]
    fn test_append_increments_sequence() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let v1 = log.append(&branch_id, "test", empty_payload()).unwrap();
        let v2 = log.append(&branch_id, "test", empty_payload()).unwrap();
        let v3 = log.append(&branch_id, "test", empty_payload()).unwrap();

        assert!(matches!(v1, Version::Sequence(0)));
        assert!(matches!(v2, Version::Sequence(1)));
        assert!(matches!(v3, Version::Sequence(2)));
    }

    #[test]
    fn test_hash_chain_links() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        log.append(&branch_id, "test", empty_payload()).unwrap();
        let event1 = log.read(&branch_id, 0).unwrap().unwrap();
        log.append(&branch_id, "test", empty_payload()).unwrap();

        // Verify chain through read
        let event2 = log.read(&branch_id, 1).unwrap().unwrap();
        assert_eq!(event2.value.prev_hash, event1.value.hash);
    }

    #[test]
    fn test_append_with_payload() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let payload = Value::Object(HashMap::from([
            ("tool".to_string(), Value::String("search".into())),
            ("query".to_string(), Value::String("rust async".into())),
        ]));

        let version = log
            .append(&branch_id, "tool_call", payload.clone())
            .unwrap();
        let seq = match version {
            Version::Sequence(s) => s,
            _ => panic!("Expected sequence"),
        };
        let event = log.read(&branch_id, seq).unwrap().unwrap();

        assert_eq!(event.value.event_type, "tool_call");
        assert_eq!(event.value.payload, payload);
    }

    #[test]
    fn test_branch_isolation() {
        let (_temp, _db, log) = setup();
        let branch1 = BranchId::new();
        let branch2 = BranchId::new();

        log.append(&branch1, "branch1_event", int_payload(1))
            .unwrap();
        log.append(&branch1, "branch1_event", int_payload(2))
            .unwrap();
        log.append(&branch2, "branch2_event", int_payload(100))
            .unwrap();

        assert_eq!(log.len(&branch1).unwrap(), 2);
        assert_eq!(log.len(&branch2).unwrap(), 1);

        // Check branch1 events
        let event0 = log.read(&branch1, 0).unwrap().unwrap();
        let event1 = log.read(&branch1, 1).unwrap().unwrap();
        assert_eq!(event0.value.event_type, "branch1_event");
        assert_eq!(event1.value.event_type, "branch1_event");

        // Check branch2 events
        let event2 = log.read(&branch2, 0).unwrap().unwrap();
        assert_eq!(event2.value.event_type, "branch2_event");
    }

    // ========== Read Tests ==========

    #[test]
    fn test_read_single_event() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let payload = payload_with("data", Value::String("test".into()));
        log.append(&branch_id, "test", payload.clone()).unwrap();

        let versioned = log.read(&branch_id, 0).unwrap().unwrap();
        assert_eq!(versioned.value.sequence, 0);
        assert_eq!(versioned.value.event_type, "test");
        assert_eq!(versioned.value.payload, payload);
        assert!(matches!(versioned.version, Version::Sequence(0)));
    }

    #[test]
    fn test_read_nonexistent() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let event = log.read(&branch_id, 999).unwrap();
        assert!(event.is_none());
    }

    #[test]
    fn test_len() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        assert_eq!(log.len(&branch_id).unwrap(), 0);

        log.append(&branch_id, "test", empty_payload()).unwrap();
        assert_eq!(log.len(&branch_id).unwrap(), 1);

        log.append(&branch_id, "test", empty_payload()).unwrap();
        log.append(&branch_id, "test", empty_payload()).unwrap();
        assert_eq!(log.len(&branch_id).unwrap(), 3);
    }

    // ========== SHA-256 Hash Tests ==========

    #[test]
    fn test_sha256_hash_determinism() {
        // Same inputs should produce same hash
        let hash1 = compute_event_hash(42, "test_event", &int_payload(100), 1234567890, &[0u8; 32]);
        let hash2 = compute_event_hash(42, "test_event", &int_payload(100), 1234567890, &[0u8; 32]);
        assert_eq!(hash1, hash2);
    }

    #[test]
    fn test_sha256_hash_differs_for_different_inputs() {
        let base = compute_event_hash(42, "test", &empty_payload(), 1234567890, &[0u8; 32]);

        // Different sequence
        let diff_seq = compute_event_hash(43, "test", &empty_payload(), 1234567890, &[0u8; 32]);
        assert_ne!(base, diff_seq);

        // Different event type
        let diff_type = compute_event_hash(42, "other", &empty_payload(), 1234567890, &[0u8; 32]);
        assert_ne!(base, diff_type);

        // Different timestamp
        let diff_ts = compute_event_hash(42, "test", &empty_payload(), 1234567891, &[0u8; 32]);
        assert_ne!(base, diff_ts);

        // Different prev_hash
        let diff_prev = compute_event_hash(42, "test", &empty_payload(), 1234567890, &[1u8; 32]);
        assert_ne!(base, diff_prev);
    }

    #[test]
    fn test_sha256_uses_full_32_bytes() {
        let hash = compute_event_hash(42, "test", &empty_payload(), 1234567890, &[0u8; 32]);

        // SHA-256 should use all 32 bytes, not just the first 8 like DefaultHasher
        // Check that bytes beyond the first 8 are non-zero (statistically likely)
        let non_zero_after_8: usize = hash[8..].iter().filter(|&&b| b != 0).count();
        assert!(non_zero_after_8 > 0, "SHA-256 should use all 32 bytes");
    }

    // ========== Query by Type Tests ==========

    #[test]
    fn test_read_by_type() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        log.append(&branch_id, "tool_call", int_payload(1)).unwrap();
        log.append(&branch_id, "tool_result", int_payload(2))
            .unwrap();
        log.append(&branch_id, "tool_call", int_payload(3)).unwrap();
        log.append(&branch_id, "thought", int_payload(4)).unwrap();
        log.append(&branch_id, "tool_call", int_payload(5)).unwrap();

        let tool_calls = log.read_by_type(&branch_id, "tool_call").unwrap();
        assert_eq!(tool_calls.len(), 3);
        assert_eq!(tool_calls[0].value.payload, int_payload(1));
        assert_eq!(tool_calls[1].value.payload, int_payload(3));
        assert_eq!(tool_calls[2].value.payload, int_payload(5));

        let thoughts = log.read_by_type(&branch_id, "thought").unwrap();
        assert_eq!(thoughts.len(), 1);

        let nonexistent = log.read_by_type(&branch_id, "nonexistent").unwrap();
        assert!(nonexistent.is_empty());
    }

    // ========== EventLogExt Tests ==========

    #[test]
    fn test_eventlog_ext_append() {
        use crate::primitives::extensions::EventLogExt;

        let (_temp, db, log) = setup();
        let branch_id = BranchId::new();

        // Append via extension trait
        db.transaction(branch_id, |txn| {
            let seq = txn.event_append(
                "ext_event",
                payload_with("data", Value::String("test".into())),
            )?;
            assert_eq!(seq, 0);
            Ok(())
        })
        .unwrap();

        // Verify via EventLog
        let versioned = log.read(&branch_id, 0).unwrap().unwrap();
        assert_eq!(versioned.value.event_type, "ext_event");
    }

    #[test]
    fn test_eventlog_ext_read() {
        use crate::primitives::extensions::EventLogExt;

        let (_temp, db, log) = setup();
        let branch_id = BranchId::new();

        // Append via EventLog
        log.append(&branch_id, "test", int_payload(42)).unwrap();

        // Read via extension trait
        db.transaction(branch_id, |txn| {
            let value = txn.event_read(0)?;
            assert!(value.is_some());
            Ok(())
        })
        .unwrap();
    }

    #[test]
    fn test_eventlog_ext_validation() {
        use crate::primitives::extensions::EventLogExt;

        let (_temp, db, _log) = setup();
        let branch_id = BranchId::new();

        // EventLogExt should also validate payloads
        let result = db.transaction(branch_id, |txn| {
            txn.event_append("test", Value::Int(42)) // primitive not allowed
        });
        assert!(result.is_err());
    }

    #[test]
    fn test_cross_primitive_transaction() {
        use crate::primitives::extensions::{EventLogExt, KVStoreExt};

        let (_temp, db, _log) = setup();
        let branch_id = BranchId::new();

        // Atomic: KV put + event append
        db.transaction(branch_id, |txn| {
            txn.kv_put("key", Value::String("value".into()))?;
            txn.event_append(
                "kv_updated",
                payload_with("key", Value::String("key".into())),
            )?;
            Ok(())
        })
        .unwrap();

        // Verify both operations committed
        db.transaction(branch_id, |txn| {
            let kv_val = txn.kv_get("key")?;
            assert_eq!(kv_val, Some(Value::String("value".into())));

            let event_val = txn.event_read(0)?;
            assert!(event_val.is_some());
            Ok(())
        })
        .unwrap();
    }

    // ========== Fast Path Tests ==========

    #[test]
    fn test_fast_read_returns_correct_value() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let payload = payload_with("data", Value::String("test".into()));
        log.append(&branch_id, "test", payload.clone()).unwrap();

        let versioned = log.read(&branch_id, 0).unwrap().unwrap();
        assert_eq!(versioned.value.event_type, "test");
        assert_eq!(versioned.value.payload, payload);
    }

    #[test]
    fn test_fast_read_returns_none_for_missing() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        let event = log.read(&branch_id, 999).unwrap();
        assert!(event.is_none());
    }

    #[test]
    fn test_fast_len_returns_correct_count() {
        let (_temp, _db, log) = setup();
        let branch_id = BranchId::new();

        assert_eq!(log.len(&branch_id).unwrap(), 0);

        log.append(&branch_id, "test", empty_payload()).unwrap();
        assert_eq!(log.len(&branch_id).unwrap(), 1);

        log.append(&branch_id, "test", empty_payload()).unwrap();
        log.append(&branch_id, "test", empty_payload()).unwrap();
        assert_eq!(log.len(&branch_id).unwrap(), 3);
    }

    #[test]
    fn test_fast_read_branch_isolation() {
        let (_temp, _db, log) = setup();
        let branch1 = BranchId::new();
        let branch2 = BranchId::new();

        log.append(&branch1, "branch1", int_payload(1)).unwrap();
        log.append(&branch2, "branch2", int_payload(2)).unwrap();

        // Each branch sees only its own events
        let event1 = log.read(&branch1, 0).unwrap().unwrap();
        let event2 = log.read(&branch2, 0).unwrap().unwrap();

        assert_eq!(event1.value.event_type, "branch1");
        assert_eq!(event2.value.event_type, "branch2");

        // Cross-branch reads return None
        assert!(log.read(&branch1, 1).unwrap().is_none());
    }
}
