//! Memory-mapped vector embeddings
//!
//! Provides a file format and reader/writer for memory-mapped vector data.
//! Used as a disk-backed cache for the global VectorHeap — if the mmap file
//! is missing or corrupt, recovery falls back to KV-based rebuild.
//!
//! ## File Format (Version 1)
//!
//! ```text
//! [magic "SVEC" 4B]
//! [version u32 LE]
//! [dimension u32 LE]
//! [count u64 LE]     — number of active vectors
//! [next_id u64 LE]   — next VectorId to allocate
//! [id_to_offset entries: count * (VectorId u64 LE, offset u64 LE)]
//! [free_slots_count u32 LE]
//! [free_slots: N * u64 LE]
//! [embeddings: contiguous f32 LE data]
//! ```
//!
//! The embeddings section is a flat array of f32 values. The id_to_offset map
//! gives byte offsets into the embeddings section (measured in f32 elements,
//! not bytes, matching VectorHeap conventions).

use memmap2::Mmap;
use std::collections::BTreeMap;
use std::fs::{self, File};
use std::io::Write;
use std::path::Path;

use crate::primitives::vector::error::VectorError;
use crate::primitives::vector::types::VectorId;

/// Magic bytes identifying a Strata vector mmap file
const MAGIC: &[u8; 4] = b"SVEC";
/// Current format version
const VERSION: u32 = 1;
/// Header size: magic(4) + version(4) + dimension(4) + count(8) + next_id(8)
const HEADER_SIZE: usize = 4 + 4 + 4 + 8 + 8;

/// Memory-mapped vector data (read-only)
pub(crate) struct MmapVectorData {
    /// The memory-mapped file
    mmap: Mmap,
    /// Dimension of each vector
    dimension: usize,
    /// Number of active vectors
    count: usize,
    /// Next VectorId to allocate
    next_id: u64,
    /// VectorId -> offset in embeddings (in f32 elements)
    id_to_offset: BTreeMap<VectorId, usize>,
    /// Free slots for reuse
    free_slots: Vec<usize>,
    /// Byte offset where embeddings data starts in the mmap
    embeddings_offset: usize,
}

impl MmapVectorData {
    /// Open an existing mmap file, validating the header.
    ///
    /// Returns `None` if the file doesn't exist or is invalid (caller falls back to KV).
    pub(crate) fn open(path: &Path, expected_dimension: usize) -> Result<Self, VectorError> {
        let file = File::open(path).map_err(|e| VectorError::Io(e.to_string()))?;
        // SAFETY: We treat the mmap as read-only and the file is opened read-only.
        let mmap = unsafe { Mmap::map(&file) }.map_err(|e| VectorError::Io(e.to_string()))?;

        if mmap.len() < HEADER_SIZE {
            return Err(VectorError::Serialization(
                "mmap file too small for header".into(),
            ));
        }

        let data = &mmap[..];

        // Validate magic
        if &data[0..4] != MAGIC {
            return Err(VectorError::Serialization("invalid mmap magic".into()));
        }

        // Version
        let version = u32::from_le_bytes(data[4..8].try_into().unwrap());
        if version != VERSION {
            return Err(VectorError::Serialization(format!(
                "unsupported mmap version: {}",
                version
            )));
        }

        // Dimension
        let dimension = u32::from_le_bytes(data[8..12].try_into().unwrap()) as usize;
        if dimension != expected_dimension {
            return Err(VectorError::Serialization(format!(
                "mmap dimension {} != expected {}",
                dimension, expected_dimension
            )));
        }

        // Count
        let count = u64::from_le_bytes(data[12..20].try_into().unwrap()) as usize;

        // next_id
        let next_id = u64::from_le_bytes(data[20..28].try_into().unwrap());

        let mut pos = HEADER_SIZE;

        // id_to_offset entries
        let mut id_to_offset = BTreeMap::new();
        for _ in 0..count {
            if pos + 16 > mmap.len() {
                return Err(VectorError::Serialization(
                    "mmap truncated in id_to_offset".into(),
                ));
            }
            let vid = u64::from_le_bytes(data[pos..pos + 8].try_into().unwrap());
            let offset = u64::from_le_bytes(data[pos + 8..pos + 16].try_into().unwrap()) as usize;
            id_to_offset.insert(VectorId::new(vid), offset);
            pos += 16;
        }

        // Free slots
        if pos + 4 > mmap.len() {
            return Err(VectorError::Serialization(
                "mmap truncated in free_slots_count".into(),
            ));
        }
        let free_slots_count =
            u32::from_le_bytes(data[pos..pos + 4].try_into().unwrap()) as usize;
        pos += 4;

        let mut free_slots = Vec::with_capacity(free_slots_count);
        for _ in 0..free_slots_count {
            if pos + 8 > mmap.len() {
                return Err(VectorError::Serialization(
                    "mmap truncated in free_slots".into(),
                ));
            }
            let slot = u64::from_le_bytes(data[pos..pos + 8].try_into().unwrap()) as usize;
            free_slots.push(slot);
            pos += 8;
        }

        let embeddings_offset = pos;

        Ok(MmapVectorData {
            mmap,
            dimension,
            count,
            next_id,
            id_to_offset,
            free_slots,
            embeddings_offset,
        })
    }

    /// Get embedding by VectorId
    pub(crate) fn get(&self, id: VectorId) -> Option<&[f32]> {
        let &offset = self.id_to_offset.get(&id)?;
        let byte_start = self.embeddings_offset + offset * 4;
        let byte_end = byte_start + self.dimension * 4;
        if byte_end > self.mmap.len() {
            return None;
        }
        let slice = &self.mmap[byte_start..byte_end];
        // SAFETY: f32 is 4 bytes, alignment is guaranteed by the file format,
        // and we've verified the bounds.
        let floats = unsafe {
            std::slice::from_raw_parts(slice.as_ptr() as *const f32, self.dimension)
        };
        Some(floats)
    }

    /// Check if a vector exists
    pub(crate) fn contains(&self, id: VectorId) -> bool {
        self.id_to_offset.contains_key(&id)
    }

    /// Number of active vectors
    pub(crate) fn len(&self) -> usize {
        self.count
    }

    /// Check if empty
    pub(crate) fn is_empty(&self) -> bool {
        self.count == 0
    }

    /// Get next_id value
    pub(crate) fn next_id(&self) -> u64 {
        self.next_id
    }

    /// Get free slots
    pub(crate) fn free_slots(&self) -> &[usize] {
        &self.free_slots
    }

    /// Get the id_to_offset map
    pub(crate) fn id_to_offset(&self) -> &BTreeMap<VectorId, usize> {
        &self.id_to_offset
    }

    /// Iterate all VectorIds in deterministic order
    pub(crate) fn ids(&self) -> impl Iterator<Item = VectorId> + '_ {
        self.id_to_offset.keys().copied()
    }

    /// Get dimension
    pub(crate) fn dimension(&self) -> usize {
        self.dimension
    }
}

/// Write a vector heap to an mmap-compatible file.
///
/// This is called after recovery/rebuild to create a disk cache.
/// The file can be opened with `MmapVectorData::open()` on subsequent starts.
pub(crate) fn write_mmap_file(
    path: &Path,
    dimension: usize,
    next_id: u64,
    id_to_offset: &BTreeMap<VectorId, usize>,
    free_slots: &[usize],
    raw_data: &[f32],
) -> Result<(), VectorError> {
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).map_err(|e| VectorError::Io(e.to_string()))?;
    }

    // Write to temp file then rename for atomicity
    let temp_path = path.with_extension("vec.tmp");
    let mut file = File::create(&temp_path).map_err(|e| VectorError::Io(e.to_string()))?;

    // Header
    file.write_all(MAGIC)
        .map_err(|e| VectorError::Io(e.to_string()))?;
    file.write_all(&VERSION.to_le_bytes())
        .map_err(|e| VectorError::Io(e.to_string()))?;
    file.write_all(&(dimension as u32).to_le_bytes())
        .map_err(|e| VectorError::Io(e.to_string()))?;
    file.write_all(&(id_to_offset.len() as u64).to_le_bytes())
        .map_err(|e| VectorError::Io(e.to_string()))?;
    file.write_all(&next_id.to_le_bytes())
        .map_err(|e| VectorError::Io(e.to_string()))?;

    // id_to_offset entries (BTreeMap iterates in sorted order)
    for (&id, &offset) in id_to_offset {
        file.write_all(&id.as_u64().to_le_bytes())
            .map_err(|e| VectorError::Io(e.to_string()))?;
        file.write_all(&(offset as u64).to_le_bytes())
            .map_err(|e| VectorError::Io(e.to_string()))?;
    }

    // Free slots
    file.write_all(&(free_slots.len() as u32).to_le_bytes())
        .map_err(|e| VectorError::Io(e.to_string()))?;
    for &slot in free_slots {
        file.write_all(&(slot as u64).to_le_bytes())
            .map_err(|e| VectorError::Io(e.to_string()))?;
    }

    // Embeddings (raw f32 data as bytes)
    let bytes = unsafe {
        std::slice::from_raw_parts(raw_data.as_ptr() as *const u8, raw_data.len() * 4)
    };
    file.write_all(bytes)
        .map_err(|e| VectorError::Io(e.to_string()))?;

    file.flush().map_err(|e| VectorError::Io(e.to_string()))?;
    drop(file);

    // Atomic rename
    fs::rename(&temp_path, path).map_err(|e| VectorError::Io(e.to_string()))?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_mmap_roundtrip() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("test.vec");

        let dimension = 3;
        let mut id_to_offset = BTreeMap::new();
        id_to_offset.insert(VectorId::new(1), 0usize);
        id_to_offset.insert(VectorId::new(3), 3usize);

        let raw_data: Vec<f32> = vec![
            1.0, 0.0, 0.0, // id=1 at offset 0
            0.0, 0.0, 0.0, // deleted slot (offset 3 would be id=2 but it's free)
            0.0, 1.0, 0.0, // id=3 at offset 3... wait, offset 3 maps to floats 3,4,5
        ];
        // Correction: offset is in f32 elements, so offset=3 means raw_data[3..6]
        let raw_data: Vec<f32> = vec![
            1.0, 0.0, 0.0, // offset 0: id=1
            0.0, 0.0, 0.0, // offset 3: free slot
            0.0, 1.0, 0.0, // offset 6: id=3
        ];
        let mut id_to_offset = BTreeMap::new();
        id_to_offset.insert(VectorId::new(1), 0usize);
        id_to_offset.insert(VectorId::new(3), 6usize);
        let free_slots = vec![3usize];

        write_mmap_file(&path, dimension, 4, &id_to_offset, &free_slots, &raw_data).unwrap();

        let mmap = MmapVectorData::open(&path, dimension).unwrap();
        assert_eq!(mmap.len(), 2);
        assert_eq!(mmap.next_id(), 4);
        assert_eq!(mmap.dimension(), 3);

        let emb1 = mmap.get(VectorId::new(1)).unwrap();
        assert_eq!(emb1, &[1.0, 0.0, 0.0]);

        let emb3 = mmap.get(VectorId::new(3)).unwrap();
        assert_eq!(emb3, &[0.0, 1.0, 0.0]);

        assert!(mmap.get(VectorId::new(2)).is_none());
        assert!(mmap.contains(VectorId::new(1)));
        assert!(!mmap.contains(VectorId::new(2)));

        assert_eq!(mmap.free_slots(), &[3]);
    }

    #[test]
    fn test_mmap_empty() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("empty.vec");

        write_mmap_file(&path, 3, 1, &BTreeMap::new(), &[], &[]).unwrap();

        let mmap = MmapVectorData::open(&path, 3).unwrap();
        assert_eq!(mmap.len(), 0);
        assert!(mmap.is_empty());
        assert_eq!(mmap.next_id(), 1);
    }

    #[test]
    fn test_mmap_invalid_magic() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("bad.vec");
        std::fs::write(&path, b"BAAD00000000000000000000000000").unwrap();

        let result = MmapVectorData::open(&path, 3);
        assert!(result.is_err());
    }

    #[test]
    fn test_mmap_dimension_mismatch() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("dim.vec");

        write_mmap_file(&path, 3, 1, &BTreeMap::new(), &[], &[]).unwrap();

        let result = MmapVectorData::open(&path, 5);
        assert!(result.is_err());
    }

    #[test]
    fn test_mmap_missing_file() {
        let temp_dir = TempDir::new().unwrap();
        let path = temp_dir.path().join("nonexistent.vec");

        let result = MmapVectorData::open(&path, 3);
        assert!(result.is_err());
    }
}
