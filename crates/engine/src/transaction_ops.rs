//! TransactionOps trait - unified primitive operations
//!
//! This trait expresses Invariant 3: Everything is Transactional.
//! Every primitive's operations are accessible through this trait,
//! enabling cross-primitive atomic operations.
//!
//! ## Design Principles
//!
//! 1. **Reads are `&self`**: Read operations never modify state
//! 2. **Writes are `&mut self`**: Write operations require exclusive access
//! 3. **All operations return `Result<T, StrataError>`**: Consistent error handling
//! 4. **All reads return `Versioned<T>`**: Version information is never lost
//! 5. **All writes return `Version`**: Every mutation produces a version
//!
//! ## Usage
//!
//! ```text
//! db.transaction(&branch_id, |txn| {
//!     // Read from KV
//!     let config = txn.kv_get("config")?;
//!
//!     // Write to Event
//!     let event_version = txn.event_append("config_read", json!({}))?;
//!
//!     // Update State
//!     txn.state_set("last_event", Value::from(event_version.as_u64()))?;
//!
//!     Ok(())
//! })?;
//! ```

use strata_core::{
    BranchMetadata, BranchStatus, Event, JsonPath, JsonValue, MetadataFilter, State, StrataError,
    Value, VectorEntry, VectorMatch, Version, Versioned,
};

/// Operations available within a transaction
///
/// This trait expresses Invariant 3: Everything is Transactional.
/// Every primitive's operations are accessible through this trait,
/// enabling cross-primitive atomic operations.
///
/// ## Implemented Operations
///
/// - **KV**: key-value get, put, delete, exists, list
/// - **Event**: append-only event log with hash chaining
/// - **State**: compare-and-swap state cells (init, get, cas)
/// - **JSON**: document operations with path-based access
///
/// ## Not Supported in Transactions
///
/// - **Vector**: requires in-memory index backends; use `VectorStore` directly
/// - **Branch**: metadata/status operations; use `BranchIndex` directly
///
/// These return `Err(StrataError::InvalidInput)` with guidance on the
/// correct API to use.
pub trait TransactionOps {
    // =========================================================================
    // KV Operations (Phase 2)
    // =========================================================================

    /// Get a KV entry by key
    fn kv_get(&self, key: &str) -> Result<Option<Versioned<Value>>, StrataError>;

    /// Put a KV entry (upsert semantics)
    fn kv_put(&mut self, key: &str, value: Value) -> Result<Version, StrataError>;

    /// Delete a KV entry
    fn kv_delete(&mut self, key: &str) -> Result<bool, StrataError>;

    /// Check if a KV entry exists
    fn kv_exists(&self, key: &str) -> Result<bool, StrataError>;

    /// List keys matching a prefix
    fn kv_list(&self, prefix: Option<&str>) -> Result<Vec<String>, StrataError>;

    // =========================================================================
    // Event Operations (Phase 2)
    // =========================================================================

    /// Append an event to the log
    fn event_append(&mut self, event_type: &str, payload: Value) -> Result<Version, StrataError>;

    /// Read an event by sequence number
    fn event_get(&self, sequence: u64) -> Result<Option<Versioned<Event>>, StrataError>;

    /// Read a range of events [start, end)
    fn event_range(&self, start: u64, end: u64) -> Result<Vec<Versioned<Event>>, StrataError>;

    /// Get current event count (length of the log)
    fn event_len(&self) -> Result<u64, StrataError>;

    // =========================================================================
    // State Operations (4 MVP)
    // =========================================================================

    /// Read a state cell
    fn state_get(&self, name: &str) -> Result<Option<Versioned<State>>, StrataError>;

    /// Initialize a state cell (fails if exists)
    fn state_init(&mut self, name: &str, value: Value) -> Result<Version, StrataError>;

    /// Compare-and-swap a state cell
    fn state_cas(
        &mut self,
        name: &str,
        expected_version: Version,
        value: Value,
    ) -> Result<Version, StrataError>;

    // =========================================================================
    // Json Operations (Phase 4)
    // =========================================================================

    /// Create a JSON document
    fn json_create(&mut self, doc_id: &str, value: JsonValue) -> Result<Version, StrataError>;

    /// Get an entire JSON document
    fn json_get(&self, doc_id: &str) -> Result<Option<Versioned<JsonValue>>, StrataError>;

    /// Get a value at a path within a JSON document
    fn json_get_path(
        &self,
        doc_id: &str,
        path: &JsonPath,
    ) -> Result<Option<JsonValue>, StrataError>;

    /// Set a value at a path within a JSON document
    fn json_set(
        &mut self,
        doc_id: &str,
        path: &JsonPath,
        value: JsonValue,
    ) -> Result<Version, StrataError>;

    /// Delete a JSON document
    fn json_delete(&mut self, doc_id: &str) -> Result<bool, StrataError>;

    /// Check if a JSON document exists
    fn json_exists(&self, doc_id: &str) -> Result<bool, StrataError>;

    /// Destroy a JSON document (same as delete, for API consistency)
    fn json_destroy(&mut self, doc_id: &str) -> Result<bool, StrataError>;

    // =========================================================================
    // Vector Operations (Phase 4)
    // =========================================================================

    /// Insert a vector into a collection
    fn vector_insert(
        &mut self,
        collection: &str,
        key: &str,
        embedding: &[f32],
        metadata: Option<Value>,
    ) -> Result<Version, StrataError>;

    /// Get a vector by key
    fn vector_get(
        &self,
        collection: &str,
        key: &str,
    ) -> Result<Option<Versioned<VectorEntry>>, StrataError>;

    /// Delete a vector
    fn vector_delete(&mut self, collection: &str, key: &str) -> Result<bool, StrataError>;

    /// Search for similar vectors
    fn vector_search(
        &self,
        collection: &str,
        query: &[f32],
        k: usize,
        filter: Option<MetadataFilter>,
    ) -> Result<Vec<VectorMatch>, StrataError>;

    /// Check if a vector exists
    fn vector_exists(&self, collection: &str, key: &str) -> Result<bool, StrataError>;

    // =========================================================================
    // Run Operations (Phase 5 - Limited, runs are meta-level)
    // =========================================================================

    /// Get run metadata (the current run)
    fn branch_metadata(&self) -> Result<Option<Versioned<BranchMetadata>>, StrataError>;

    /// Update run status
    fn branch_update_status(&mut self, status: BranchStatus) -> Result<Version, StrataError>;
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Mock implementation of TransactionOps for testing trait properties
    ///
    /// Implements KV, Event, State, and JSON operations.
    /// Vector and Branch return proper errors (matching real Transaction behavior).
    struct MockTransactionOps {
        kv_data: std::collections::HashMap<String, Value>,
        state_data: std::collections::HashMap<String, State>,
        json_data: std::collections::HashMap<String, JsonValue>,
        event_count: u64,
    }

    impl MockTransactionOps {
        fn new() -> Self {
            Self {
                kv_data: std::collections::HashMap::new(),
                state_data: std::collections::HashMap::new(),
                json_data: std::collections::HashMap::new(),
                event_count: 0,
            }
        }
    }

    impl TransactionOps for MockTransactionOps {
        fn kv_get(&self, key: &str) -> Result<Option<Versioned<Value>>, StrataError> {
            Ok(self
                .kv_data
                .get(key)
                .map(|v| Versioned::new(v.clone(), Version::txn(1))))
        }

        fn kv_put(&mut self, key: &str, value: Value) -> Result<Version, StrataError> {
            self.kv_data.insert(key.to_string(), value);
            Ok(Version::txn(1))
        }

        fn kv_delete(&mut self, key: &str) -> Result<bool, StrataError> {
            Ok(self.kv_data.remove(key).is_some())
        }

        fn kv_exists(&self, key: &str) -> Result<bool, StrataError> {
            Ok(self.kv_data.contains_key(key))
        }

        fn kv_list(&self, prefix: Option<&str>) -> Result<Vec<String>, StrataError> {
            let keys: Vec<_> = self
                .kv_data
                .keys()
                .filter(|k| prefix.is_none() || k.starts_with(prefix.unwrap()))
                .cloned()
                .collect();
            Ok(keys)
        }

        fn event_append(
            &mut self,
            _event_type: &str,
            _payload: Value,
        ) -> Result<Version, StrataError> {
            self.event_count += 1;
            Ok(Version::seq(self.event_count))
        }

        fn event_get(&self, sequence: u64) -> Result<Option<Versioned<Event>>, StrataError> {
            if sequence == 0 || sequence > self.event_count {
                return Ok(None);
            }
            Ok(None)
        }

        fn event_range(
            &self,
            _start: u64,
            _end: u64,
        ) -> Result<Vec<Versioned<Event>>, StrataError> {
            Ok(Vec::new())
        }

        fn event_len(&self) -> Result<u64, StrataError> {
            Ok(self.event_count)
        }

        fn state_get(&self, name: &str) -> Result<Option<Versioned<State>>, StrataError> {
            Ok(self
                .state_data
                .get(name)
                .map(|s| Versioned::new(s.clone(), s.version)))
        }

        fn state_init(&mut self, name: &str, value: Value) -> Result<Version, StrataError> {
            if self.state_data.contains_key(name) {
                return Err(StrataError::invalid_input(format!(
                    "state '{}' already exists",
                    name
                )));
            }
            let state = State::new(value);
            let version = state.version;
            self.state_data.insert(name.to_string(), state);
            Ok(version)
        }

        fn state_cas(
            &mut self,
            name: &str,
            expected: Version,
            value: Value,
        ) -> Result<Version, StrataError> {
            let current = self
                .state_data
                .get(name)
                .ok_or_else(|| StrataError::Internal {
                    message: format!("state '{}' not found", name),
                })?;
            if current.version != expected {
                return Err(StrataError::Internal {
                    message: format!(
                        "version conflict: expected {:?}, got {:?}",
                        expected, current.version
                    ),
                });
            }
            let new_version = expected.increment();
            let new_state = State::with_version(value, new_version);
            self.state_data.insert(name.to_string(), new_state);
            Ok(new_version)
        }

        fn json_create(&mut self, doc_id: &str, value: JsonValue) -> Result<Version, StrataError> {
            if self.json_data.contains_key(doc_id) {
                return Err(StrataError::invalid_input(format!(
                    "document '{}' already exists",
                    doc_id
                )));
            }
            self.json_data.insert(doc_id.to_string(), value);
            Ok(Version::txn(1))
        }

        fn json_get(&self, doc_id: &str) -> Result<Option<Versioned<JsonValue>>, StrataError> {
            Ok(self
                .json_data
                .get(doc_id)
                .map(|v| Versioned::new(v.clone(), Version::txn(1))))
        }

        fn json_get_path(
            &self,
            doc_id: &str,
            path: &JsonPath,
        ) -> Result<Option<JsonValue>, StrataError> {
            match self.json_data.get(doc_id) {
                Some(doc) => {
                    if path.is_root() {
                        Ok(Some(doc.clone()))
                    } else {
                        Ok(strata_core::get_at_path(doc, path).cloned())
                    }
                }
                None => Ok(None),
            }
        }

        fn json_set(
            &mut self,
            doc_id: &str,
            path: &JsonPath,
            value: JsonValue,
        ) -> Result<Version, StrataError> {
            if path.is_root() {
                self.json_data.insert(doc_id.to_string(), value);
            }
            Ok(Version::txn(1))
        }

        fn json_delete(&mut self, doc_id: &str) -> Result<bool, StrataError> {
            Ok(self.json_data.remove(doc_id).is_some())
        }

        fn json_exists(&self, doc_id: &str) -> Result<bool, StrataError> {
            Ok(self.json_data.contains_key(doc_id))
        }

        fn json_destroy(&mut self, doc_id: &str) -> Result<bool, StrataError> {
            self.json_delete(doc_id)
        }

        // Vector operations — not supported in transactions (returns proper error)
        fn vector_insert(
            &mut self,
            _collection: &str,
            _key: &str,
            _embedding: &[f32],
            _metadata: Option<Value>,
        ) -> Result<Version, StrataError> {
            Err(StrataError::invalid_input(
                "Vector insert is not supported inside transactions. \
                 Use VectorStore::insert() directly."
                    .to_string(),
            ))
        }

        fn vector_get(
            &self,
            _collection: &str,
            _key: &str,
        ) -> Result<Option<Versioned<VectorEntry>>, StrataError> {
            Err(StrataError::invalid_input(
                "Vector get is not supported inside transactions. \
                 Use VectorStore::get() directly."
                    .to_string(),
            ))
        }

        fn vector_delete(&mut self, _collection: &str, _key: &str) -> Result<bool, StrataError> {
            Err(StrataError::invalid_input(
                "Vector delete is not supported inside transactions. \
                 Use VectorStore::delete() directly."
                    .to_string(),
            ))
        }

        fn vector_search(
            &self,
            _collection: &str,
            _query: &[f32],
            _k: usize,
            _filter: Option<MetadataFilter>,
        ) -> Result<Vec<VectorMatch>, StrataError> {
            Err(StrataError::invalid_input(
                "Vector search is not supported inside transactions. \
                 Use VectorStore::search() directly."
                    .to_string(),
            ))
        }

        fn vector_exists(&self, _collection: &str, _key: &str) -> Result<bool, StrataError> {
            Err(StrataError::invalid_input(
                "Vector exists is not supported inside transactions. \
                 Use VectorStore::exists() directly."
                    .to_string(),
            ))
        }

        // Branch operations — not supported in transactions (returns proper error)
        fn branch_metadata(&self) -> Result<Option<Versioned<BranchMetadata>>, StrataError> {
            Err(StrataError::invalid_input(
                "Branch metadata is not supported inside transactions. \
                 Use BranchIndex methods directly."
                    .to_string(),
            ))
        }

        fn branch_update_status(&mut self, _status: BranchStatus) -> Result<Version, StrataError> {
            Err(StrataError::invalid_input(
                "Branch status update is not supported inside transactions. \
                 Use BranchIndex methods directly."
                    .to_string(),
            ))
        }
    }

    // ========== Object Safety Tests ==========

    /// Verify trait is object-safe by creating a trait object
    fn accept_dyn_transaction_ops(_ops: &dyn TransactionOps) {}

    fn accept_mut_dyn_transaction_ops(_ops: &mut dyn TransactionOps) {}

    fn accept_boxed_dyn_transaction_ops(_ops: Box<dyn TransactionOps>) {}

    #[test]
    fn test_trait_is_object_safe_ref() {
        let ops = MockTransactionOps::new();
        accept_dyn_transaction_ops(&ops);
    }

    #[test]
    fn test_trait_is_object_safe_mut_ref() {
        let mut ops = MockTransactionOps::new();
        accept_mut_dyn_transaction_ops(&mut ops);
    }

    #[test]
    fn test_trait_is_object_safe_boxed() {
        let ops = MockTransactionOps::new();
        accept_boxed_dyn_transaction_ops(Box::new(ops));
    }

    // ========== Read Operations Through Trait Object ==========

    #[test]
    fn test_kv_operations_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        // Put through trait object
        let version = ops.kv_put("key1", Value::Int(42)).unwrap();
        assert_eq!(version.as_u64(), 1);

        // Get through trait object
        let result = ops.kv_get("key1").unwrap();
        assert!(result.is_some());
        let versioned = result.unwrap();
        assert_eq!(versioned.value, Value::Int(42));

        // Exists through trait object
        assert!(ops.kv_exists("key1").unwrap());
        assert!(!ops.kv_exists("nonexistent").unwrap());

        // Delete through trait object
        let deleted = ops.kv_delete("key1").unwrap();
        assert!(deleted);
        assert!(!ops.kv_exists("key1").unwrap());
    }

    #[test]
    fn test_event_operations_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        // Append events
        let v1 = ops
            .event_append("UserCreated", Value::String("alice".into()))
            .unwrap();
        let v2 = ops
            .event_append("UserUpdated", Value::String("bob".into()))
            .unwrap();

        // Check versions are sequential
        assert_eq!(v1.as_u64(), 1);
        assert_eq!(v2.as_u64(), 2);

        // Check length
        assert_eq!(ops.event_len().unwrap(), 2);

        // Non-existent event (beyond the event count)
        assert!(ops.event_get(999).unwrap().is_none());
    }

    #[test]
    fn test_kv_list_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        ops.kv_put("user:1", Value::Int(1)).unwrap();
        ops.kv_put("user:2", Value::Int(2)).unwrap();
        ops.kv_put("config:a", Value::Int(3)).unwrap();

        // List all
        let all_keys = ops.kv_list(None).unwrap();
        assert_eq!(all_keys.len(), 3);

        // List with prefix
        let user_keys = ops.kv_list(Some("user:")).unwrap();
        assert_eq!(user_keys.len(), 2);
        assert!(user_keys.iter().all(|k| k.starts_with("user:")));
    }

    // ========== State Operations Through Trait Object ==========

    #[test]
    fn test_state_init_and_get_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        // Initialize state
        let version = ops.state_init("counter", Value::Int(0)).unwrap();
        assert_eq!(version, Version::counter(1));

        // Read state back
        let result = ops.state_get("counter").unwrap();
        assert!(result.is_some());
        let versioned = result.unwrap();
        assert_eq!(versioned.value.value, Value::Int(0));
        assert_eq!(versioned.value.version, Version::counter(1));
    }

    #[test]
    fn test_state_cas_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        ops.state_init("counter", Value::Int(0)).unwrap();
        let new_version = ops
            .state_cas("counter", Version::counter(1), Value::Int(42))
            .unwrap();
        assert_eq!(new_version, Version::counter(2));

        let result = ops.state_get("counter").unwrap().unwrap();
        assert_eq!(result.value.value, Value::Int(42));
    }

    #[test]
    fn test_state_cas_version_mismatch_returns_error() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        ops.state_init("counter", Value::Int(0)).unwrap();
        let result = ops.state_cas("counter", Version::counter(99), Value::Int(1));
        assert!(result.is_err());
    }

    #[test]
    fn test_state_init_duplicate_returns_error() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        ops.state_init("counter", Value::Int(0)).unwrap();
        let result = ops.state_init("counter", Value::Int(1));
        assert!(result.is_err());
    }

    // ========== JSON Operations Through Trait Object ==========

    #[test]
    fn test_json_create_and_get_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        let doc: JsonValue = serde_json::json!({"name": "Alice"}).into();
        ops.json_create("user:1", doc.clone()).unwrap();

        let result = ops.json_get("user:1").unwrap();
        assert!(result.is_some());
        assert_eq!(result.unwrap().value, doc);
    }

    #[test]
    fn test_json_delete_through_trait_object() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        let doc: JsonValue = serde_json::json!({"key": "value"}).into();
        ops.json_create("doc", doc).unwrap();
        assert!(ops.json_exists("doc").unwrap());

        let deleted = ops.json_delete("doc").unwrap();
        assert!(deleted);
        assert!(!ops.json_exists("doc").unwrap());
    }

    #[test]
    fn test_json_create_duplicate_returns_error() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        let doc: JsonValue = serde_json::json!({}).into();
        ops.json_create("doc", doc.clone()).unwrap();
        let result = ops.json_create("doc", doc);
        assert!(result.is_err());
    }

    // ========== Vector/Branch Operations Return Proper Errors (Not Panics) ==========

    #[test]
    fn test_vector_operations_return_errors_not_panics() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        // All vector operations should return Err, not panic
        assert!(ops.vector_insert("col", "k", &[1.0], None).is_err());
        assert!(ops.vector_get("col", "k").is_err());
        assert!(ops.vector_delete("col", "k").is_err());
        assert!(ops.vector_search("col", &[1.0], 5, None).is_err());
        assert!(ops.vector_exists("col", "k").is_err());
    }

    #[test]
    fn test_branch_operations_return_errors_not_panics() {
        let mut ops: Box<dyn TransactionOps> = Box::new(MockTransactionOps::new());

        // Branch operations should return Err, not panic
        assert!(ops.branch_metadata().is_err());
        assert!(ops.branch_update_status(BranchStatus::Active).is_err());
    }

    // ========== Trait Method Signatures ==========

    #[test]
    fn test_read_methods_take_shared_ref() {
        // This test verifies that read methods use &self (not &mut self)
        // by calling them on an immutable reference
        let ops = MockTransactionOps::new();
        let ops_ref: &dyn TransactionOps = &ops;

        // All these should compile with &self
        let _ = ops_ref.kv_get("key");
        let _ = ops_ref.kv_exists("key");
        let _ = ops_ref.kv_list(None);
        let _ = ops_ref.event_get(1);
        let _ = ops_ref.event_range(1, 10);
        let _ = ops_ref.event_len();
    }

    #[test]
    fn test_write_methods_take_mutable_ref() {
        // This test verifies that write methods use &mut self
        let mut ops = MockTransactionOps::new();
        let ops_mut: &mut dyn TransactionOps = &mut ops;

        // All these should compile with &mut self
        let _ = ops_mut.kv_put("key", Value::Int(1));
        let _ = ops_mut.kv_delete("key");
        let _ = ops_mut.event_append("test", Value::Null);
    }
}
